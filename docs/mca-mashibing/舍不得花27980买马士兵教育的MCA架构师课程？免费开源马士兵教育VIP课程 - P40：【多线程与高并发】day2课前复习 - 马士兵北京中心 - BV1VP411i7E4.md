# 舍不得花27980买马士兵教育的MCA架构师课程？免费开源马士兵教育VIP课程 - P40：【多线程与高并发】day2课前复习 - 马士兵北京中心 - BV1VP411i7E4

OK不多说了，我们稍微回顾一下上节课我们讲的多线程和高并发这方面内容，回顾一下啊，讲了线成的概念，这非常简单，启中的方式。嗯，你有一个thread start。用runable来启动。

用executor来启动。常用了一些方法，sleep wait join。县城如果需要同步加synchronized。schronized不能用常量。不能用tring类型的常量啊。

不能用基础数据类型、indi long等等。哦。线轴的臀步。它呢锁的是对象，而不是代码，这一定要记清楚。你锁的是某一个对象，是通过这个对象的对象头上面的两位来控制是不是加了锁，加了什么类型的锁嗯。

锁呢一般来说默认的会有锁this锁当前对象锁。什么什么的class所整个这个class类的对象。什么时候呢？如果你是普通的方法，schronized的M普通方法锁的是this。

如果是static synchronized的，那么锁的就是什么什么点class。锁定的方法和非锁定的方法是可以同时执行的。非锁定方法人家本身就不需要去访问这个锁。所以呢你锁不锁跟我没有任何关系。

所以你要想如果说你的某一个类想支持类行多线程的话，你得特别特别小心翼翼的来进行设计。呃，什么样哪些方法要加锁哪些方法呢？不加锁。所升级的概念呢就是schronize的内部呢进行了一些相应的优化。

所升级的概念我们来稍微回顾一下。这个从阿里的这种面试的变态来看的话呢，这种题后面也会慢慢的会被问到。什么叫所升级的概念呢？所升级的概念就是嗯你比如说你要锁定某一个对象，那么前面我说过。

我说在这个对象头上的某两位。来指定它到底锁的什么类型的锁。在对像头上还记录着当前现城哪个县场啊，哪个县城申请了这把锁。那偏向锁的概念是什么呢？这线程来了之后呢，先不尝试给它进行加锁。

只是记录这个线成的ID值，线程ID记在这儿。那么我们就认为呢这个对象呢是这个县城独有。下次再来申请这把锁的时候啊，他就会认为就是那个那个倾向于还是这个这个线程。

那就是说这个锁呢实际上是偏向于这个第一次拿到这把锁这个线程的，所以他没有真正的加锁，它只是说你下次来的时候判断你如果还是原来那个线程呢，就你就别加锁了，继续直接访问，不要考虑这个加锁的问题啊。

因此呢效率上会稍微高一些啊，但是如果来的县程，新的这个线程呢，不是原来那个你发现新的这个线程ID和原来这个线程ID呢，它不等在不等的情况下怎么办呢？进行锁升级。进行锁升级。

锁升级呢首先会尝试进行自选锁的升级。什么意思呢？从偏向所升级为自选锁自选锁呢？就是说呃如果说这个线程在这已经拿到这把锁了。那么另外一个线程来了之后呢，跟着转圈。询环。Well。哎，我能不能拿热么锁啊。

能不能拿这么锁啊，能不能拿热么锁啊，跟这转圈，转十圈，默认是这个值是是转十圈，如果拿不着，这时候干嘛升级重量级锁。这哥们儿就去wait了，大家知道重量级锁的概念就是说经过我们的OS，然后进入等待队列啊。

进入在等待队列里头。进入等待队列之后呢，它就不再占用CPU时间了。所以它占用CPU时间，占用时圈，时圈完了之后呢，就进入等待队列。什么时候用自选锁，什么时候用重量你锁呢？嗯你你你还还记得吗？

如果说上节课没听你好好你考虑一下这个问题。根据自选锁和重量级锁的特点，什么时候是自选，什么时候重量级锁。自选所咱们说线程数少的时候，线程数偏少的时候使用自选还是用重量级比较合适。如果其他条件都一样。

这肯定是自选。没错，这大家都很这很很很很很简单，宣投数少，你选两下呢消耗的时间也不多。但是如果现成数特别多，你跟这自权还有意义吗？2000个县城，一个县城在那儿。厕所上蹲着2000个县城在旁边转圈。

你盯得住吗？这肯定不行。所以一个是哎这给大家写一下吧。自学叫做积极的排队啊，它是占用CPU时间的。如果你是为它队列呢，哎，它就不是不占用CPU时间搁那等着啊，消不不消耗CPU的。所以如果现成数少。

这个呢平该是偏向于自悬。如果多的话呢，应该是偏向于重量计算。只有一在那儿跑就行了。那我再问你。呃，大家知道你拿到这把锁之后要执行操作。如果这个操作的消耗时间长。来告诉我用自学还是用重量激锁。考虑一下。

不量解锁。是不是？
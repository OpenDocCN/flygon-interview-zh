# 马士兵教育MCA架构师课程 - P65：循环依赖问题 - 马士兵学堂 - BV1RY4y1Q7DL

来先说明一下到底什么叫做循环依赖，这东西啊也比较简单，什么叫循环依赖呀，我们都知道在spring中，对象的创建是交给容器框架来执行的，那么bin是默认是单例的还是原型的，案例吧。

也就是说在整个容器框架里面，对象有且仅有一个，那么这个时候就可能会存在一种情况，我这里面有一个对象是aa对，象里面呢有一个b属性对吧，同时我还有一个b对象，当我在进行这两个对象赋值的时候。

就会产生循环依赖问题，那到底是如何产生呢，其实也非常简单，你想嘛，现在我的容器里面有两个对象，不管先创建a还是先创建b，总之我是要先创建一个对象的，我们可以举一个假设，假设我先创建的是a对象。

如果我先创建a对象的话，那行吧，先进行a对象的实例化，当实例化完成之后，我要给a对象里面的b属性进行赋值操作了，诺问下我在赋值的时候，我有b对象吗，刚开始肯定没创建b对象嘛，所以我开始创建b对象了。

当我创建完b对象之后，我要给b对象进行a属性赋值的，那么这个时候a是不是也没创建完成，所以它就变成了一个链式的结构，也就是说变成了一个闭环，当形成这个闭环的时候，它就形成了一套循环依赖。

也就是我们循环引用这个过程，这个时候程序就会报错，告诉我们说程序继续执行编下去啊，我们要想办法让程序能执行下去啊，这是我们循环依赖，最直接或者最简单的一个例子，当然有人说老师如果是三个对象，四个对象。

五个对象呢，不管你有多少对象，整体的逻辑都是这个样子的，所以这点大家没必要有任何的一个疑惑，然后呢，今天的课程是跟昨天的课程相关联的，我昨天在讲spring的ioc的时候，我初说了，病人生命周期里面。

包含了n多个环节和n多个步骤，那我问一下在哪些环节和步骤里面，最主要的是什么，是不是两个呢，是不是有两个名词，第二名词叫做实例化，第二名词叫做初始化吧，所以我们完全可以以一种画图的方式，来模拟一下。

这个循环依赖问题到底是如何产生的，这个图只是一个最基本的简略图，它不足以表达我们在实际情况里面，要存在的情况，那怎么来创建这件事情啊，很简单，第一件事我说了，比如说先创建就创建创建a对象，这没问题了。

当我创建a对象的时候，同学们，你想下一步该干嘛了，如果你想创建a，必然是不是涉及到一个实例化的过程，所以紧跟着后面的一个步骤是啥啥东西，你们来说好吧，不要让我来说啥玩意儿，啊实例化吧，你说实例化a对象。

当实例化完成之后，我想问的是，此时里面的b属性等于什么，那么肯定是默认值嘛，刚开始等于是空的，然后当这步完成之后，紧跟着下一步我要做一个操作叫初始化，a对象，那说白了什么叫初始对象，不就是给b属性。

赋值吗，是不是逻辑给b属性赋值，而在赋值的时候，我们都知道容器里面对象默认是单例的，所以为了他为了得到我们的b对象，那你告诉我下一个步骤我应该干嘛，是不是紧跟着，应该是去叫从容器中。

是不是从容器中查找b对象吧，视频查找比对象，我要找到了，你说这既然是查找了，意味着一定涉及到两个结果，第一个找到了，第二个没找到，我们先说如果找到了得到，抓到之后怎么办，是不是直接赋值即可对吧。

他直接给我们当前这个对象赋值连过来结束了，那很多情况下是什么，是没找到吧，所以这有一个问题就是没找到，如果没找到怎么办，我是不是该创建b对象了，一定要创建吧，你不创建的话，这个步骤是没法做的。

所以该创建b对象了，这搁这儿能理解的来，能跟上的，给老师扣个一，能看到吗，这没问题吧，最基本的一个环节，然后下面当创建b对象之后，跟刚刚的流程是一模一样的，这步骤叫实例化，实例化，b对象对吧，然后呢。

此时a等于空，那下面再在做这个操作的时候，紧张到后面就开始叫初始化，b对象说白了就是给a属性赋值，那同样的，当我在给a属性赋值的时候，我是不是一样要去容器里面查找，我们当前的a对象了。

随便一样拿过来容器中查找a对象，当我在进行查找的时候，也百分之百会需要一个东西，或者存在两个结果，要不然你找到了，要不然你没找到，就这两个来，先说右边右边这块，如果我找到了，抓住怎么办。

是不是说了就直接赋值即可，然后呢下面这连下来结束，那下面这儿呢如果没找到，我说又开始进行整个a对象的创建了，来这个流程或者这个过程能看懂吗，正版题吧，没对齐是吧，就这样吧，无所谓啊，这没问题吧。

来你看一下，当前这个图里面还有没有一个闭环存在，一定有吧，从创建a对象开始到往后走，它形成了一个闭环，那我问一下，当前闭环存在的原因到底是因为什么，谁能告诉我，那为什么参加一个闭环，在闭环形成的时候。

中间必然包含了一个非常重要的核心步骤，就在于这一块，如果这个地方，如果这个地方我找到a立项了，我是不是就不会有闭环了，或者换句话说，如果我能把这个东西给阻断掉，它还有闭环吗，这就没有了。

所以当它形成这样的一个闭环套路之后，我们就要去思考一件事了，思考什么事情，我能否把当前的闭环给它解开，不要让它变成一个圈，因为你变成一个圈之后就很麻烦哇，他一直一直这样走。

那你就想我怎么做这件事情还是一样，注意你在找闭环的突破口的时候，先从哪开始找，从最后一个步骤形成闭环的这个步骤开始，从这儿开始，这个环节明白意思吧，这样大家要注意了，那我问一下。

当我这儿开始查找a对象的时候，在刚刚整个创建流程里面，我的a对象到底你有没有创建，有没有，听我的问题啊，在这一块我在查找的时候，我的a对象到底有没有创建，有说没有，有说有框架了吗。

这白字白纸黑字写的明明清清白白的，就是创建a对象吧，我其实已经有一个a对象了，只不过当前这个a对象，不是我们传统意义上的a对象，啥意思，对象在创建过程中，它存在了两种状态，好这状态哪两种状态。

第一种状态叫做完成实例化且完成初始化，这个时候我们给它一个名词，比如说叫产品对象，没问题吧，那一样的我可以再换一个叫完成实例化啊，但未完成初始化，我们把它称之为另一个名词叫半成品。

半成品对象这样东西能理解吗，看来这个过程这两个成品和半成品能理解的，扣个一就可以理解吧对吧，这就是说我在对象的时候，两个不同的状态到底是什么东西，那您想一件事，当我最后一步在形成这个闭环的时候。

我现在的a对象它属于成品还是属于半成品，怎么样吧兄弟，半成品吧，对不对，半成品，那紧跟着就会有一个问题和一个步骤来，有一个问题等大家什么问题，如果我持有了某一个对象的引用，那么能否在后续的步骤中。

给当前对象进行赋值操作，能还是不能，听完这个问题啊，这个问题才是最关键的核心点和最本质的东西，如果我持有了某一个对象的引用，那么我能否在后续的某一个步骤中，给当前对象进行复制操作，可以吧。

你有了应用之后，有了引用之后，我能知道他对象的地址，那我一定能够对它进行相关的一个复制操作，就肯定是可以的，如果这个步骤可以的话，那我们就要去思考一件事情了，什么事情，这个步骤我要去查找a对象。

我虽然获取不到完整的a对象，但是我是能够获取到半成品的a对象了，这肯定没问题吧，所以是不是相当于我们可以把这个步骤给干掉，也就说它是不存在的，不存在的话，也就意味着我们在刚刚上面整个查找的环节。

或者过程中，我要加一个东西，加什么，就是大家说的加缓存这玩意儿好吧，加换的这玩意儿怎么加呢，没有半成品啥意思，完成了实例化，但没有完成初始化吗，我昨天不是讲i o c的时候。

不把大家给大家讲了一下bean的生命周期吗，在bean的生命周期里面，是不是分了大概的微景模块，实例化对吧，初始化，然后又分为使用中，然后就属于销毁，是不是四个状态。

然后我们初始化里面又包含了很多个步骤，我们把这东西统一来说了，统一来说了，好吧，同学描述了，所以这时候你想当，我还是沿着这条链路来走的时候，我实例化完a对象之后，我能不能把当前的这个a对象。

把它放放到某一个空间里面去，举例子，我这儿放一个结构，放啥呢，放一个map结构，我把这个map称之为缓存，可以吧，每次当我存储完具体的一个对象之后，我创建了一个对象之后，我先把当前的a对象放到缓存里面。

那现在我的问题是，什么状态，半成品状态吧，记住啊，半成品状态记住它，然后往后几面接着走，当我走到这个环节的时候，叫初始化a对象里面的b属性，也就是说我给b属性要进行复制操作了，我一定从中心里面查到b。

查到b的时候，我能不能去当前的缓存里面找一下，可以吧，我从缓存里面找b的时候，你告诉我我能找到b对象吗，找不到吧，因为他还没开始创建吗，所以一定找不到，找不到我再接着往下走，我开始创建b对象。

当我的b对象创建完成之后好了，这叫实例化b对象吗，我能不能把我的b对象，也扔到当前的环境里面去，可以吧，此时我的b对象它也是什么状态，叫半成品状态都是半成品，不管它都是半成品。

然后我现在给b对象里面的a属性赋值，我这儿从容器里面找的时候，我能不能从当前缓存里面也找一份，这可能没问题吧，我在找这个a对象的时候，你告诉我这里面现在有没有a对象，有吧一定是有的，我是不是有一个对象。

当我这有对象之后，是不是意味着我已经找到当前的a对象了，哪怕你现在的a对象，它就是一个半成品，也没关系，我就只能找到他，我想找他，找到之后，我把刚刚的半成品对象我赋值给b属性，那我问一下啊。

当我这个地方我找到我们的a对象了，当我这儿找到之后，现在我的b是什么状态，是不是没b是不是已经变成一个成品了，它依然是一个半成品，就相当于我持有了当前a对a对象的，什么引用吧。

我在后面的时候我再给它完成赋值操作，是不是这意思，所以现在b已经变成一个成品对象了，那我现在我b的成品要不要往缓存里面放，没有问题啊，要不要往这里面放，不用啊，不要你后面怎么找啊，要吧。

就意味着账号存在一这样就写叫b冒号成品，是不是意思，这没问题吧，叫b叫成品，接过来，然后我这放进去之后，下面紧跟着回到这个环节里面，现在如果我再去我们的容器里面，查找b对象的时候，我能不能找到b对象。

先留着好吧，我们先写，先先留着，先写到这儿，先写到这儿，这儿能不能获取到，能吧好吧，那你想我这应该取的是b的半成品，还是取得b的成品，取半的面试成品，你有成品了，我肯定取成品对象吗，对吧。

所以这个时候我找到b的成品对象，当我找到之后，我给a里面的b属性来赋值操作，那我问一下，现在我们的a对象它属于什么，属于什么东西，成品了吧，a也是成品了，对不对，所以我把a我也写进来，a，很好成品。

同学们，你想一件事，当刚刚这个流程我总体都完成之后，我有没有解决刚刚我所说的循环依赖问题，你先不考虑缓存里面这个半成品和成品的事儿，好吧，解决了吗，是不是解决了。

这就是spring中到底是如何解决循环依赖问题的，但这里面还有问题，因为我这边写的时候，其实刚刚在写的时候，同学们都发现问题了，老师当你形成了一个成品的a和b对象之后，我不会对这玩意儿进行覆盖。

为什么你这个缓存里面它既存在了ab的半成品，又存在了ab的成品对象，这很明显不太合适，是不太合适，那我怎么办，所以大家就要考虑一件事了，这个map到底是啥玩意儿，而据我们刚刚那个流程，听明白。

同学给老师扣个一，我看看，没问题吧，我把这个框一下，换个色儿，来看一下，这流程我觉得听懂应该没问题吧，说听懂没问题好吧，只不过对于这个map这大家还有疑问，那么这还有疑问。

所以我们之前按照我不讲这节课之前，你们的理解怎么解决循环依赖问题呢，spring如何解决循环依赖问题的，基本上所有看过帖子和面试中，被问到过题的同学都会答一个东西叫三级缓存，当然还有同学会说一句话。

叫什么叫提前暴露对象，是不是意思就是说通过这样的方式来解决，这没问题吧，但是你注意了，其实它解决循环依赖的问题，最根本的点在于什么地方，在于一个东西，记住了，叫实例化和初始化分开来操作。

我们刚刚能划开这样的一张图，是因为我把实例化和初始化的步骤是分开了，这是因为分开了，所以你才能完成这样一件事，那我问一下，有人见过spring的三级缓存到底是什么东西吗，或者到底长什么样子吗。

有人见过吗，三级缓存到底啥玩意儿，很多同学光在输三级缓存，三级缓存是韩信卖方还是control，韩信卖方还是卖方。



![](img/a2f506801820ea86f830631c4bd8b140_1.png)

来，我带你们看一下好吧，在spring源码中有一个类。

![](img/a2f506801820ea86f830631c4bd8b140_3.png)

我希望你能记住叫default呃，singleton。

![](img/a2f506801820ea86f830631c4bd8b140_5.png)

并register在当前对象里面有三个缓存结构。

![](img/a2f506801820ea86f830631c4bd8b140_7.png)

分别是这玩意儿。

![](img/a2f506801820ea86f830631c4bd8b140_9.png)

我把这三东西拿出来粘出来，吃子弹粘过来。

![](img/a2f506801820ea86f830631c4bd8b140_11.png)

我给你们放到这儿，把三东西拿过来。

![](img/a2f506801820ea86f830631c4bd8b140_13.png)

这就是spring里面的三级缓存，好吧，来解释一下三级缓存分别是啥东西，比如说第一个像这块singleton object，它称之为叫一级缓存，我需要把这个字改一下颜色。



![](img/a2f506801820ea86f830631c4bd8b140_15.png)

![](img/a2f506801820ea86f830631c4bd8b140_16.png)

这么说的，一级缓存就这玩意儿好吧，同样的还有二级缓存是这东西，这叫二级缓存啊，那一样的，还有三级缓存，就是中间那块它叫做三级缓存，我希望同学们能明白一件事，这里面所说的一级也好，二级也好，三级也好。

是人为给它下的一个定义，它在它这个三个麦和定义的时候，并没有明确说明说哪哪个是一级，哪个是二级，哪个是三级，用人类给它加上这样一个东西好吧，那这个时候我的问题就来了，同学们什么问题。

这三个缓存它们有什么样的区别，有区别不，诶有区别吗，有没什么区别，任老师，他们有的是concut哈希map，像一级和二级都是concut哈希map，而三级变成了哈希map，还有他们的容量是不一样的。

上面是256，一级缓存，256，二级和三级是16，还有吗，除了value这些这些东西不一样之外，还有什么不一样，其实三个缓存里面最最最最大的一个区别，并不在于后面这块东西，它只是为了控制线程是否安全的。

最根本的点在于泛型，我希望你能够好好看一下这个泛型，一级缓存和二级缓存别，我放的全部都是object类型的对象，就是一个对象吧，但是我的三级缓存里面放了什么叫object factory。

这个object factory到底是啥东西，你们知道吗，啥玩意儿，记住它叫做函数式接口，函数式接口不是工厂对象好吧，不要直译，不要直译，千万不要直译好吧，它叫做函数式接口，你可以理解为它可以把什么。

把匿名内部类和拉姆达表达式传递，进去当做参数，好我们来看一下。

![](img/a2f506801820ea86f830631c4bd8b140_18.png)

找到一个对象object b，上面写的东西叫functional interface，叫函数式接口，如果谁不了解什么叫函数式接口，同学好，下去之后好好看一下jdk一点八之后的新特性，这属于一个新特性。

其实也没有什么难理解的啊，就算函数接口，那它有哪些用途呢，就是我们可以传递一个匿名内部类，或者传递一个拉姆达表达式进去，相当于是一种函数式编程了，我问一下，在原生的java jdk里面或者java里面。

我能传一个函数当作参数吗，能不能不能吧，但是当你有了函数式接口之后，它可以定义一个函数式接口的参数类型，然后我可以把拉姆达式传进去，而我在进行调用的时候，可以通过get object来进行相关的调用。

就这意思，比如你写的函数接口，括号指向再写一个create b，假如你写这样一个方法，当写方法之后，它就变成一个函数接口，我传到这三种里面去了，当我在调get object方法的时候。

实际上掉的就是create bean这个方法啊，这属于一个最基本的一个应用。

![](img/a2f506801820ea86f830631c4bd8b140_20.png)

好吧，如果谁这块不熟的话，你先来看一下。
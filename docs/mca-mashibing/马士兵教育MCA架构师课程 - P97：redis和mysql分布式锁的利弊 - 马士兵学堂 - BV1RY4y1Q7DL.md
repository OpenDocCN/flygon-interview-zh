# 系列 6：P97：redis和mysql分布式锁的利弊 - 马士兵学堂 - BV1RY4y1Q7DL

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_0.png)

ok你现在把这个问题给放大。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_2.png)

你现在把这个集群给放大，听我说啊，把集群给放大，比如说我现在这个集群一共有1000台redis，有1000台release，我现在增加了一台release，现在就变成了1001台，我现在增加了1000。

现在就是1001台了对吗，那你新增这台数据库，你只需要与两台redis发生数据迁移，剩下的九呃999台，不需要动不需要动，来听懂的，再次六六告诉我，如果其中一台挂了一会儿再说好吧。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_4.png)

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_5.png)

如果把集群放大，那么这个哈希一致性算法，它的优势非常非常的突出。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_7.png)

优势非常突出，其实啊哈希一致性算法，也有弊端，它容易发生数据倾斜，哈希一致性算法它容易发生数据倾斜，对。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_9.png)

为什么说它会发生数据倾斜呢，刚才有同学说让我简单的介绍一下。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_11.png)

介绍什么是是是这么不是你回去看看录播吧。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_13.png)

如果你中途来的话，我建议你看看看录播好吧，如果跟不上的话，为什么说会有数据倾斜，听到这个数据倾斜，大伙应该知道什么是数据倾斜吧，对于我们的存储框架来说，数据倾斜就是指，大部分的数据存在了少量的节点上。

少量的数据存在了大部分的节点上，那么对于计算框架来说，大部分的数据由局部的线程去处理，少量的数据是由大量的线程去处理对吧，那比如说我们现在redis在映射的时候这样映射的，这是我们的raid 1。

然后reid 2在这个位置，他俩挨得很近，他俩挨得很近。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_15.png)

那挨得很近的话，俗凡是映射在这半段的数据，是不是存在reid 2上，凡是映射在这半段的数据是不存在read一上，那这就是数据严重失衡了，这就发生数据倾斜，对吧，这个数据倾斜怎么解决啊，怎么解决啊。

应该能听懂吧，数据的存储策略是这样的，这半段它顺时针找不找的都是rider 2吗，那你这半段顺针找是不是找的都是ready，一，凡是映射在这半段的数据都存在这一上。

凡是硬是在这半段数据是不是都存在这点二上。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_17.png)

就这个意思怎么解决啊，这个数据倾斜，我们可以搞虚拟节点，我们可以搞虚拟节点，就你red一多虚拟出来几个，redis啊，假设就虚拟一个吧，然后redis 2啊，你也虚拟出来一个，现在是这样的。

每一个节点各虚拟出来一个节点，那也就是说这半段存在ready 2上，这半段是不存在这个虚拟的reid 2上，其实你存在这个虚拟的ring 2上，说白了是不是还是存在我这个redis 2上对吗。

然后映射在这一半段的存在它上，应该在这半段的存在它上，那说白了这半段实质是不是还是存在的意义上，这就可以来解决数据倾斜，那有同学说，我虚拟出来的节点有可能还是不均衡。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_19.png)

那就增加虚拟节点，这也是一个trade off，ok，啊通过哈希槽来实现的哈希一致性啊，它的哈希槽有161率多少呢，16384还是多少嗯，16384是吧，o好了哎。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_21.png)

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_22.png)

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_23.png)

这是关于这个缓存的雪崩啊，进而给大家延伸出来的。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_25.png)

进而延伸出来的。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_27.png)

那么接下来顺着刚才那位同学的问题，就是哈希啊，不是不是就这个缓存的雪崩啊，和这个缓存的击穿有什么区别，来缓存击穿，听过的扣一，没听过的扣二。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_29.png)

不要一部分同学听过，一部分同学没听过啊。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_31.png)

缓存击穿就是指在我的缓存从中，直缓存了一条数据，听好了啊，只缓存了一条数据啊，那雪崩呢它是缓存了多条数据，多条数据同时失效，我们称为雪崩，那么击穿就是缓存一条数据，你这一条数据失效所发生的问题。

叫缓存击穿问题，但它俩的区别就是一个是一条，还是另外一个是多条对吗，我把这三个概念我先给大家捋一下啊，别乱缓存，雪崩，缓存击穿，还有一个是缓存穿透，这三个概念来捋一下，记住一句话，记住一句话，缓存穿透。

缓存击穿，缓存雪崩，本质都是，它的本质都是缓存穿透，那么缓存雪崩和缓存击穿啊，它是缓存穿透的特殊表现来，这句话很重要，能听明白的扣666，来有感觉的666，他粉丝吧，粉色的。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_33.png)

你看不管是缓存击穿还是缓存雪崩啊。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_35.png)

其实是不是都是缓存穿透啊。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_37.png)

对不对呃，传统，我。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_39.png)

这个袋子说一致性哈，希虚拟间之后带扩容，是不是又回到解放前了，你要想你哪怕搞个虚拟节点，你再扩容，它也不会让你集群内部发生偏大大规模的泛红，听懂了吗，也不会发生大规模的泛红。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_41.png)

那么关于缓存击穿，我们再深入聊一下啊，这也是面试常问的，这个是克莱的客户端，那你说我现在这个redis里边啊，它只存了一条数据，只存了一条热门数据，并且这条热门数据是不是有条切啊。

他先去ready中查ready没有呃，里边没有，是不是再去mysql里面查对吧，如果在某一刻这条数据失效了，那么所有请求。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_43.png)

这条数据的请求是不是全部会打向mysql，全部打下mysql，那我问你缓存击穿问题，在一般的公司里边，我需不需要解决啊，我需不需要解决啊，你觉得需不需要解决，给我一个感性的回答，给我一个感性的回答。

不需要就是在一般的公司啊，不需要解决，为什么呢，就一般的公司，你很难有一条那么热门的数据。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_45.png)

能够足以让你的mysql瘫痪，来能够听懂的666告诉我，就一般的公司很难有一条那么热的数据，能够让你的数据库给瘫痪对吧，所以我建议各位你们出去面试的时候啊，希望你们回答问题，要联系上下文啊。

context，联系上下文，如果在你的简历上，你写的你上一家公司是一个并发量并不高，或者数据量并不大，用户量也不大的。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_47.png)

人家问你，你的缓存击穿有没有解决啊，结果你听了我今天给你讲的课之后。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_49.png)

啪啪啪跟人家聊出来，你不打自己脸吗。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_51.png)

这是一般公司不需要解决，其实有的时候面试官会拿这一道题啊，他会去校验你是否真的玩过，他会去校验你曾经工作经验的一个真实性，数据面试要也要学会避坑，ok那么对于大公司来说肯定需要解决对吧。

大公司肯定需要解决啊。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_53.png)

一般解决缓存机舱的方案是什么啊，我们可以使用分布式锁来解决，使用分布式锁来解决，来分布式锁，了解的同学扣一，不了解的扣二，刚才我大概估算了一下，百分之七八十的同学不了解。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_55.png)

我们来讲好好听，好好听，原理上的问题才是最重要的，思路上的问题，这是最重要的。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_57.png)

不错了，真的思路决定出路，一定记好了，什么是分布式锁啊。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_59.png)

先来给大家把分布式锁聊透，然后我再告诉你，怎么使用分布式锁来解决所谓的缓存击穿问题。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_61.png)

好吧，来从一个很简单的问题开始讲，首先锁这个东西啊，我觉得不需要给他给大伙讲了，很简单，我们上厕所睡觉是不是都需要加锁啊，比如说你们公司里边有个厕所啊，有一个厕所啊，厕所里边只有一个坑，只有一个坑。

那这时候你上厕所的时候是不是要锁门啊对吗，举个例子，比如说现在有这么三个人，马老师，朱老师，一鸣哥哎，这三个人他们晚上一起出去吃饭，去了某一个餐厅，然后吃完饭之后，老板没做没做熟，拉肚子。

厕所只有一个厕所，里边只有一个坑，那么他们就不要来抢这个厕所啊，那上面有有一把锁，他们需要来抢，那这个时候谁抢到是谁先进去，进去之后把门儿是不是在反锁上对吧，你看这个场景就需要上，就需要加锁这个场景。

这个场景啊它是具备的三个条件，你发现了没，第一个条件，在这个场景下有一个共享资源，就这个操作，第二个条件，这是一个多任务的环境对吧，第三个条件，我这个共享资源啊是互斥的，因为我只有一个坑啊，你在这蹲着。

我就不能蹲，发现了吗，请各位记好，凡是你的场景满足这三个条件，你都需要上锁啊，缺少任何一个条件都不需要加速啊，都不需要加速，你比如说我们第三个条件没有，就这个共享资源它不是互斥的，而我删掉，那你需要我。

我说需要你，你说我需要上锁吗，不需要来马老师要蹲了来蹲，这周老师又来了，哎蹲着挨着牌子蹲着啊，一鸣哥来了，哎，挨着牌蹲着哎，定对定，不需要上锁啊，对不对。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_63.png)

这是我删了第三个条件，如果我把第二个条件删了，现在不是这三个人要上厕所了，就马老师一个人要上，或者公司里边就马老师一个人，那你说他上厕所需要锁门吗，不需要啊，没别人啊，唉我给你解释清楚的66号数。

但凡是你的业务下。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_65.png)

凡是你的业务符合这三个条件都需要加锁对吧，我们抛开这些坑不说啊。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_67.png)

这个例子实在是太形象了，太细碎了，我们重新换一个例子，陈先再换一个例子，比如说卖票，啊这是我卖火车票票的一个窗口，就一个啊就一个窗口，然后现在有这么三个人，123所谓的人就是一个个的three的线程。

就一个个线程，这三个线程它是处于同一个jvm里面，哎处于同一个gm里面，你看到这个场景下满不满足这三个条件，能满足吧。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_69.png)

首先共享资源，这个共享这个窗口是不是只有一个，还说明共享资源是互斥的，这是不是也是一个多任务的环境，是的，所以他们这三个人去买票是需要加锁，能听懂了吧，唉我们可以使用jdk给我们提供那些所机制。

就可以实现这三个人挨着牌排队的去买票啊，如果现在所谓的这三个人啊，不是县城，是一个个的jvm，这个是jvm 2，这个是jvm 3，请问各位我在使用jdk给我提供的那些锁机制，能不能实现。

让他们排着队挨着牌子去买票啊，咱觉得可以的扣一，不可以的扣二，这时候就不行了，对不对，你这里可以提高那些所机制，你只能解决你当前jvm内部的排队问题，你解决不了jvm之间的排队问题对吗。

你解决不了jvm之间，那怎么办啊，唉我们可以基于jvm之上去搞一把锁，唉可以基于jvm之上搞一把锁，比如说你把这把锁是存到了mysql里边，ok这叫基于mysql的分布式锁，基于mysql的分布式锁。

ok具体来聊一下流程，你现在三个人是不是都要去买票啊，怎么办呀，来先去我mysql里边来抢所，所谓的强所就是去你mysql里边insert一个字段，谁先insert进去，代表谁抢到了锁，听懂了吗。

来三个人都来抢锁，都去音色的数据，也就是说对吧，比如说g v m一先抢到这把锁，唉这个时候他是不是就可以来买票了，当他买完了票，再去mysql中把刚才insert进去的那个值再干掉，这代表释放锁。

释放完锁之后，剩下这俩是不是又可以再继续抢了，假设j v m2 又抢到了，他又来买票，这样就可以实现一个排着队挨着牌子去买票。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_71.png)

这把锁就叫分布式的锁，为什么给它取个名字叫分布式的锁啊，你看不同的j v m有可能在不同的节点上，那么你多个节点我们就叫分布式，这把锁是控制多个节点上的jvm的一个一致性，或者说排队问题。

所以它叫分布式的锁，来给你讲清楚的，66告诉我，这个分布式锁很简单啊，对可以理解成就是一把大锁啊，控制的时候你多个jvm挨着旁排着队，问题，那么基于mysql的分布式锁啊，其实它有一些问题的。

它有一些问题的，它会容易存在一个死锁问题，它又存在一个死锁问题，为什么说会有死锁呢，比如说我这个gm一先抢到了所，他抢了锁之后啊，是不是来买票啊，对吧，假设就在买票的过程中，gbm一宕机了死了。

他就说我mysql里边的这个字段值，是不是永远不会被删除啊，那么jvm 2和j v m3 ，永远都不能去insert数据了，就永远抢不到锁了，这就发生了子锁，听懂了吗，来听懂的扣一为什么会有思索。

刚才给大家去分析了一下，哎我们可以怎么办啊，就针对于这个死锁问题，我们可以怎么解决啊，刚才我看有同学已经把这个答案说出来了，我们可以搞监听啊，我们可以搞监听，比如说我现在这有个j v m。

启动了这么一个进程，这个进程做什么事呢，就是来监视这把锁，来就是来监视这把锁，如果这把锁，存在的时间，超出我们设定的time out，那么这个m一就可以把这把锁给干掉，你看啊。

gm一强盗了所在买票的过程中死了怕吗，不怕他是不是在一直监视着，超过了他们是不会把这把锁给干掉，那剩下的两个g v m又可以来抢，所又可以去买票了，这就可以解决，唉强制回收可以这么说，嗯这个词很好。

我们搞了这样一个进程，在这监视着这把锁，其实又会引来新的问题，又会引来新的问题，我这个time up怎么设置啊，射多长啊，你能告诉我吗，就我这个time out设置应该怎么，我应该设多长，天津。

能说吗啊恐怕谁都说不出来，恐怕谁都说不出来，就是他们up设多长也同时设1年嗯，其实射多长谁都没有一个标准，如果你这个time out，我刚才也有个同学看也看了，有同学说设1ms，设1mm就是射的很短。

那么射的很短会有什么问题啊，g m m一先抢到锁在这买票，就在买票的过程中发生了j c，发生了jc，jc发生了一秒，这个时候你这个jvm这个监视的进程，是不是已经把你这把锁给干掉了。

但人家gbm一只是趴在这个卖票窗口那，睡了一会儿，睡着了就睡了，那么一会儿你把你就把我的锁给干掉，把我的锁给干掉，剩下的gb m2 和gbm 3，是不是又可以来抢来抢锁了，假设接下来是jvm 2强到锁。

那么j b m2 是不是又来了，这个时候在在这个时刻，就会有两个人趴在这个窗口，那么在现实场景就会打架，那么在编程环境下就会存在着一票多卖问题。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_73.png)

来我给你讲明白了，66告诉我，对线程不安全，所以这是我们设的过短，如果我们设的过长呢，就你们说的1年啊，我不知道这个答案是你考虑过的，还是说随随口而出的，如果设为1年会有什么问题啊。

那设备1年刚才的问题肯定能解决对吗，来gm一抢到了锁，在这买票买票过程中挂了，那么就在那一秒钟挂了。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_75.png)

是不需要等这么长时间，剩下两个gm是不是才能买票，本来我今年想回家，结果只能明年回家了，对吗啊，有同学说设60年，本来我想在老家安享晚年，只结果只能，你们懂了对吧。



![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_77.png)

所以说如果你设的过长，它就会存在单位时间内，不能卖出，更多的票啊。

![](img/789c1f995af2b6ea5b04ffa6fc9de0ff_79.png)
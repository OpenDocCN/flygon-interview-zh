# 系列 1：P3：JVM瞬间涨薪3K的操作：3.CMS的理论与缺陷 - 马士兵官方号 - BV1mu411r78p

把它记录为灰色有什么好处，当我垃圾回收线程再次回来的时候，我只需要从灰色开始就可以了，我不需要从根上开始开始好，我这个垃圾回收线程，把这个灰色的以及他的孩子全部找到了，他有俩孩子，比如说全都找到了。

那我也就把它变成黑色好了，找到他了，还没有找到他的孩子，这哥俩是灰的，那就意味着当我下次回来的时候，我只需要从灰的开始就可以了，我没有必要从黑的开始，如果没有这个颜色的记录。

就意味着我每次都都得从头开始，这样我就不能构建整个的树的图谱了，来这块儿能听，应该能听懂吧，没问题的，老师扣一好吧，什么时候我把整个的全找，就是整个内存里的对象全找完一遍了，我就已经知道哪些是垃圾。

哪些不是垃圾了，琢磨琢磨是不是格上到这儿哎，找到他了，这次呢我找到他，找到这哥俩，找到这儿了，当我们下次垃圾回收器再回来的时候，我就顺着这哥俩就是往下找找找再找找，当我们说这哥俩都没孩子了。

那说明我们整个已经找完了，那剩下的所有的全是垃圾，ok这是三色标记算法，三色标记算法它会发生这样一种情形，往这儿看，仔细往这儿看，我们现在假设我们的内存里头站在垃圾回收器的角度，我们内存长这样。

有一个a已经找到他的孩子，b也已经被我找到，但是呢这个b的小孩d还没有来得及找我的垃圾回收器暂停，我刚才说了，垃圾回收器是有可能被暂停，那就是一个普通县城嘛，然后业务线程继续，请大家注意。

这个时候业务线程很有可能会干这么一件事儿，有一个a的引用，a的有一个属性的引用指向了d注意看，与此同时，b，指向d的引用消失了，那么从伪代码的角度来说，就是这样写，就是a里面有一个小对象啊。

比方说它叫小d等于d对象，与此同时，我们业务代码很很可能会执行这样的这样的一种情况，很正常，好那现在我问你，当我垃圾回收器再次回来的时候，根据我刚才所说的业务逻辑，那就刚才说的算法逻辑，sorry。

我的垃圾回收计现在回来了，回来了之后呢，由于a是黑色的，我还去找他的孩子吗，不找，由于b是灰色的，我去找他的孩子，但是由于他也用消失了，我还能找得到地吗，找不到。

那我想问你这个d是不是就被我们当成垃圾了，他有用，但是被我们当成垃圾了，这就是为什么我们没找到对象，会被我们造成垃圾的原因，那这样回收不慢吗，narrow，你在说啥，ok这段呢我估计有同学可能会有疑问。

我稍微暂停一小下嗯，听听大家伙的问题啊，这样业务不会有bug吗，你给我举个例子，这业务为什么会有bug呀，大哥离谱，这个算法这个bug也太loop，不是这个算法我还没有讲完呢。

三色标记算法本人是这么算的，明白吧，嗯笑傲江湖说明白了，因为都是继续上一次的地方找，搜不出来对啊，最关键的点就是在这儿他会继续上一次，你如果每次都重新找，那你对这个你这个垃圾回收算法还有什么效率可言呀。

我们每成成百上千的对象，你每次重新找，那你还不得s t w吗，是不是，d还在用，但是被清理了，没错这个不是县城所控，这跟县城所有有半毛钱关系吗，你为什么会跟县城所有关系，这个算法跟现场所没有关系。

你好好想想，无非就是在我们业务线程执行了一小会，然后垃圾回收线程执行小伙，呃面试的时候我说了三次标记算法，面试验效果，从来没有听说过三次标记融，你说了一个很很严重的问题，小小荣哥佩服诶，小龙哥去哪儿了。

一不小心把小荣哥点没了，这以前咱们同学遇到过，就是他那个呃比面试官的知识稍微丰富一些，然后呢他就上来怼了面试官一通，然后给了面试官详细地讲解了整个的知识体系，然后你猜猜看他面进去了吗，然后挂了。

对他绝对挂了，很少有那种心胸特别开阔的面试官，你比我还牛逼，你别进来了，他说没有听说过三次标记，你一定要顺着他说，你说唉对，那我可能是记错了，很多吧新生开过对，其实也有很多，开个玩笑了，嗯这个是分人的。

是的嗯，三色具体是什么数据存储的，我估计会有同学问这个问题啊，我觉得没有同学问这个问题不正常，三色具体是以什么数据存储的来，各位大哥，这是所有初级的程序员，初初级的入门级的经常会问到的。

说老师那个三色是难道是真的在上面染点颜色吗，我说别扯淡，这个对象啊，它到底是什么颜色的，其实非常非常非常的简单，它有好多种方式可以标示它，第一个我们可以存储一个颜色表，每每一位来代表一个对象，说。

这个对象呢它的颜色如果嗯有两位吧，一零代表黑色，零一代表灰色，一代表白色，可不可以，完全可以，甚至你可以存在这个对象的指针上，这个指针不是有64位吗，目前这64位用用不完，可以在他头上给他挪。

挪出两位来来代表这个对象的颜色还可以怎么办，当然cm s不是这么干的啊，c m s干法是什么，在这个对象脑袋上明白吗，听过我以前课的同学应该知道每一个对象啊，都有一个对象头，头部叫对象的header。

这个头部的话呢叫mark word，mark word标记字，mark word呢在这个mark word里面拿出两，位来来代表你到底是什么颜色的，可不可以都可以啊，具体看你这vm怎么实现了。

只要你能代表状态就行，红黑树，这跟红黑树有半毛钱关系吗，嗯好嗯，我我讲到了这种算法的问题了，可以继续的给老师扣一，好同学们听我说呃，刚才我说过了啊，说我们再看一遍这个动画，其实为了给大家想说明这个问题。

想了半天，只能做动画啊啊这是我们第一次垃圾回收的时候看到的，我们最终的一个情形，a黑色比灰色地白色，我们正常的情况下呢，应该回来之后呢，顺着b继续找到d这是最合理最完美的情况。

但是由于在我回来的过程之中，拉业务线程积蓄发生了这样一种情形，a指向了d b指向d的引用消失了，所以我再也找不到他了，那这时候怎么办呢，办法就是我们需要加一些个所谓的专业名词叫屏障。

但是这跟那个呃内存里面呢说内存乱序执行的那个屏障是两码事儿，它指的是什么呢，指的是当我一旦看到垃圾回收器啊，就是整个呃sorry，整个jvm它会观察，当我一旦看到有黑色对象的引用指向白色对象的时候。

它会加一些操作，他发现了a a的引用指向了a a的这个这个引用指向了d，然后呢a是黑色，d是白色，那这时候怎么办呢，最简单的把a标成灰色就可以了，能不能听懂，就是jvm自己帮你观察了，这，件事。

然后自己帮你把这个a给你变成灰的，所以最简单的办法就是当我们有这样产生的时候，把a变成灰的，同学们，你们想一下，把a变成灰了之后，我们垃圾回收就回收回来，发现a是灰色的，那是不是我顺着a还得继续找啊。

又找到了b又找到了d，所以这就不再会产生漏掉了，来这个解决方案就是cm s所采用的方案，它的全称呢叫incremental update，增量更新啊，简单吧，是不是很简单，对没错啊。

所以这个就是cms的所采用三色标记算法，b为什么不变白色，b为什么要变白色呀，b最后是会变成黑色的，就是说所有的对象啊，在最终的时候它一定都会变成黑色，就是当我的b找到了，他又没有孩子变黑。

当我所有对象都变黑了，那么意味着我找到了所有有用的对象了啊，跟b没关系，好吧嗯，好嘞好嘞好嘞，当我们理解了这件事之后，呃，有同学说通过写屏障，写屏障是什么意思，我刚才也解释过了，就是a。x等于d。

当我们jvm观察到这样一句话的时候，他会在后面帮你加一句话，加什么呢，就是把a。color等于black设成黑色，这射成灰色，sorry，射成灰色啊，灰色是green，ok好这块还有有没有有疑问的。

业务一直运行，找不完呀，难道一直不清理，怎么会找不完呀，为什么找不当，我们有一天一定会找完呀，把所有的东西都找完吗，那a上一个节点指向d呢，a上一个节点a上一点，看它什么颜色吗，你琢磨琢磨。

如果b的应用断了呢，be的应用断了，那说明它就是垃圾啊，b的只是说b的应用，你如果只是b的引用在这里断掉了对吧，然后这个也就没有这里断掉了，那不就是垃圾了吗，没关系的啊，无所谓啊。

这里不是正常理解的屏障啊，这个跟那个跟那个跟那个内存里面我们所说的那个屏障不是一回事，好吧，这个不用sw多少一个时间片就找完了，是的是这样的，把地变灰不是效率更高吗，把d变灰为什么效率会更高。

找到d d还有孩子呢，d得找完孩子找d，如果有孩子变灰，那地那个那个那个如果还没找到他的孩子的话，那只能是灰色，等找完之后才能变成黑色，好吧，它的关键在于是我们呃标记的整个过程跟我们业务线程。

它两个可以同时运行，这个是不是收集完一次就重新从新开始扫，为什么要重新从头开始扫，为什么是怎么理解的嗯，a b之间断掉的时候，b是灰的时候诶，那无所谓啊，那它就是垃圾了，ab之间断掉就是垃圾。

假如说你这时候b是灰色的时候断掉了，那b呢就多多找他一遍，能听懂吗，这个不就上一个问题了吗，刚才那个问题，刚才小伙说说a b啊，这时候a是黑的，b是灰的，然后呢把这部分给干掉了，那意味着回来的时候呢。

我得继续从b找，对不对，没关系啊，不就多找两次吗，找完之后呢，发现他不是垃圾，认为它不是垃圾，所以这次不清理，下一次回来就把它清掉了，这不就是上一次上个上一个问题吗，浮动垃圾。

但是中间标记就不用sl节省很多时间，是的没错好，我们可以继续吗，可以继续给老师扣，一来还没有讲完，还没有讲完，虽然看上去这个解这个解决方案看上去是如此的简单，但是呢在这个如此简单的解决方案里面。

隐藏了巨大的bug，认真听，只有理解了这件事情之后，我们才能够理解这个bug是什么，你再仔细看呃，现在呢我们垃圾回收的站在一个垃圾回收器的角度啊，呃垃圾回收线程的角度，他整个标标标标顺着刚刚开始找。

找到了，目前的时候呢，在他的眼里，整个的对象的对象图是这样的，a是黑的，b是灰的，d是白的，还没有找到，那好在他离开的这段时间，业务线程呢b指向d的影消失了，与此同时a指向d的也增加了，那么回来之后呢。

他会找不到d，所以解决方案是jvm本身，虚拟机本身，它因为它运行嘛，它是运行运行你这个语句它一定会观测到有一个语句是a的黑的，指向了一个b的白的对象，那么它在后面给你加一句，把a变成灰的。

这样的话你垃圾回收线程在回来的时候，a和b都是灰的，所以你可以顺着他们继续找，写篇章的时间是什么，就是这vm给你加的语句吗，这个有什么难以理解的吗，为什么使使劲问这个问题呢。

jvm本身是不是可以给你加汇编语言，它自己实现的不是随便加吗，就给你加上就行了，就把a变成灰的了，所以当我拉圾回收线程回来的时候，就不会漏掉d了，听懂了吧，可以继续吗，可以继续给老师扣一来。

因为这块确实比较复杂，稍微难一点点，忍受一点啊，同学们认真听，今天我给你讲的稍微难一些，明天我就给你讲，稍微容易一些的，不论什么样的人都能听懂的，就是我给你分析整个大厂的职级，这块也是非常有价值的啊。

咱们这儿阿里的老师非常多，现在给大家讲课的已经到p9 了，所以呢跟大家解释解释这个知己对你将来的升职加薪也超级重要啊，ok当你理解了这件事之后，就是把它a变灰。

这种解决方案叫incremental update，就是为了不漏标掉这个d那好，但是这个解决方案的背后隐藏了巨大的bug，下面未必所有人都能听懂了，我感觉可能会一直循环，你感觉你的感觉有问题好吧。

好认真看这个就这个bug呢不是所有人都能听懂了，但是呢能听懂就听听不懂啊，你就记住cms解决方案有巨大的bug，好巨大bug在哪儿，就在于这儿，如果a有两个属性，一个叫一，一个叫二好听。

我说比如说啊我们有一个垃圾回收线程，他现在正在标a，注意它已经标完了属性一了，也就是说通过这个一这个属性啊，已经找到他一个孩子了，但是还没有来得及标它的属性二，那我问你a现在是什么颜色，a什么颜色。

a标了一半了，还没有标完，他的所有的孩子，a什么颜色呀，对a是灰色好看，这里，好标了，他一个小孩还没来及，标二，这时候a是灰色的，这时候这个垃圾回收线程暂停，暂停好。

这时候呢我们的业务逻辑线程有一个业务逻辑线程，把这个一注意是这一指向了白色对象，然后呢大家刚才我们分析过啊，说这个一指向白色对象，然后b指向d的已经消失了，同学们，你们想象一下。

按照我们刚才的分析的东西啊，就是我们jvm啊本身是一定要把它标灰的，对不对，它本身是灰色，我现在一定要把它标灰好，假设我这个过程处理完了，我把你标灰了，但是呢我们原来那个垃圾回收显示又继续。

我们原来垃圾回收线程继续的时候呢，把二也给标完了，站在垃圾回收器的角，垃圾回收线程的角度来说，我把一个对象的一和二，所有的子属性全标完了，那么这个对象应该，变成什么颜色，应该变黑，能听懂吗。

我们再来分析一下这个过程，这个过程比较复杂，仔细听，当我有一个垃圾回收线程，把这个一啊标完了，还没有来得及标二，在他眼里，这哥们儿是灰色，然后呢，这哥们暂停业务线程一指向了d b指向了d的引用消失。

好jvm把它变成灰色，等着下一次继续扫描，要扫描这个一是吧，1v一指向的引用变了嘛，但是我这个垃圾回收线程回来继续，因为他一在他眼里看来已经标完了，该标二了，把二标完，标完之后整个变黑。

那就意味着同学们你们想想看，是不是这个地又找不着了，因为，它已经变黑了吗，d还是被漏了，现在a是黑的，好了，来这块儿，他的问题能听明白的，给老师口音，今天有点复杂是吧，本来这个a应该是灰的。

jvm也把它标灰了，但是我的第一个垃圾回收线程认为我把所有属性全标完了，我把你干成黑色，然后完蛋了，我这个引用指向的这个d又找不着了，这么多假装听懂了吗，大哥你是真的没听懂啊，我这么耐心的一点点的。

然后用动画的方式给你演示，不是每次都从第一个车厢开始检查吗，谁告诉你的，每次都从第一个，那还有什么用吗，你这个算法每次都做根上算，你这个算法有什么用吗，你你算完一遍跟没算是是一样的呀。

他怎么知道一标注了，内部有一个记录表，好吧，每个对象重新算大哥，我们是把所有的这从内存里面来说呢，它是一棵对象树，是不是稍微稍微再拧一点点，这个讲这个东西呢，每次讲这个我也我也比较头疼。

我也想给你们讲点简单的，但是好多人说简单不解渴嘛，内存里头我们在某一个瞬间，它一定是一个对象数，这个对象指向这个对象，这个对象只有对象呢已经变成垃圾了，就是它我们为了把这个对象树给找出来。

只有找到这颗对象树，剩下的那些全才能不是垃圾，那剩下那些才是垃圾，才能把它干掉，那为了找这个对象数，你不能从头每次都从头开始找啊，因为数很大，你根本找不完，内存特别大的时候，你这个数根本找不完。

那你sw时间不还是很长吗，你如果每次都从头找到尾的话，那怎么办呢，我就从每次从根儿，上找根儿上找完之后呢，我找到这一层，我就暂停一下，然后回来的时候我继续能听懂吗，所以它就是分分好多好多次的线程运行。

才能够标记完整个的这个对象数，但是在标记整个对象数的时候，对象数又在变，所以我们要解决的问题是在它变的时候还不会产生漏标，主要是考虑到这个问题啊，好，可以继续吗，老师1年多少万，你把这个问题弄明白了。

1年50万没问题，放心吧啊，好，所以呢为了解决这一系列的漏标问题，我们用了三色标记算法，那么三色标记算法呢为了解决三色标记算法里面的罗标问题，c m s呢采用了把黑色变灰的方案。

这种方案就是increment al update，但是这种方案有特别隐蔽的问题，就是我刚才给大家演示的好吧，好同学们听我说，cms后来发现了哦，原来我有特别特别隐蔽的问题，依然会产生漏标。

那这时候怎么办呢，认真听。
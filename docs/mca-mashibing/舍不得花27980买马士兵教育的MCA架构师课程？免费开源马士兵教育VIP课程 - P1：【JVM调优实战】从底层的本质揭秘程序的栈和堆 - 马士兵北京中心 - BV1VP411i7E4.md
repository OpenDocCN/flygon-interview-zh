# 舍不得花27980买马士兵教育的MCA架构师课程？免费开源马士兵教育VIP课程 - P1：【JVM调优实战】从底层的本质揭秘程序的栈和堆 - 马士兵北京中心 - BV1VP411i7E4

O。这是第一次这么来讲这个JVM啊，我我先说一下今天讲课的原则。今天讲课的这个原则呢是照顾基础稍差的同学。当然我速度也不会慢，你要有一定基础的同学呢，你也可以呃是吧？你稍微宽容一些啊。

等等稍微基基础差一点点的那个这个这个同学啊，但是我速度也不会慢，大家放心。好，听我说今天呢我主要给大家今明两天吧，我主要给大家去聊这个GC的内容。今天我来讲这个理论，明天我来讲实践。

我们把它一个作为一个完整营务。呃，听完这个营之后呢，你能达到的效果是什么呢？你可以在简历上写写啥写这个叫熟悉GC的常用算法，熟悉常见的垃圾收集器啊，熟悉常见的垃圾收集器，具备实际GM调调优实战的经验。

就是说你听完今明两天的课，差不多有三四个小时。就直接可以在你简历上写上这么一条来，不知道有多少同学能够意识到，当你在简历上写这么一条的时候，你这份简历。可以多值多少钱呢？Yes。不是。大三可以写吗？

可以啊，没问题啊，这跟你大几没有半毛钱关系啊。可以出去吹牛逼了，不用吹牛逼啊，这个是真正值钱的地儿。我告诉你，3000块钱至少。你在简历上写这个，原来你简历值1500，现在就值18000。好，看到里。

今天开始听我慢慢道来，好吧。今天呢我主要给大家讲呢到底什么是垃圾，怎么定位这个垃圾常见的算法，常见的垃圾回收器。呃，调优的时战我明天讲好吧，调优实战呢比较难，稍微复杂一些啊，说说错了。

其实那个实战相对容易，理论相理论啊相对比较难。我们一点点讲放松了讲。今天我也是第一次这么来讲，我怎么讲呢？我是从那个。最底层的一个本质来跟大家聊。嗯哼嗯う。首先呢给大家呃几十秒钟，你扫一下这张图。

看是不是能理解。Okay。嗯。😊，嗯，我看满天志说工资才3000，没关系啊，听完就6000。人要有梦想，要不然跟咸鱼有什么区别呢？好。又是这张图。对。长途几百年不变。只要是冯诺伊曼结构的。

冯诺伊曼杰优的计算机体系不变，这张图就永远不变。耐克都有张图嗯。每周。哪克还有马老师呢。好看这里。嗯，作为一台计算机来说。怎么样这个程序是怎么样运行的呢？这里是QQ点EXE平时呢它静静的躺在硬盘上。

我想静静是吧？静静的躺在硬盘上。什么时候它执行呢？当你双击这个图标。操作系统老大会把它从硬盘load到内存。好，这过程呢我们叫load。漏到内存。漏到内存之后，这哥们儿会形成一个进程。ok。

会在内存里面形成一个进程。这进程里面包括什么呢？包括一条条的指令，一条一条的数据。然后接下来。CPU会一句一句的一条一条的指令拿到自己的内部来开始执行。需要数据的时候呢，再把数据给读过来。

他真正开始执行了之后呢，实际上他还是需要内存的辅助。好。这个进城的内部到底是怎么组织的呢？好好听我讲，这精神内部怎么组织的呢？呃，这块我就简单介绍到这，没问题吧嗯。可以关一下微信的声音哦，sorry。

你提醒了我。稍等片刻。好了，这下世界安静了。Yeah。是怎么组织的呢？在这里呢我介绍程序的。战和堆的概念。程序的战和真，也许有同学了解过，也许有同学不了解，你认真听就可以了。呃，我们来看这样一个小程序。

这是我刚刚敲的。假如说啊我们自己写了一个main函数ma方法，我在里面是这么写的，是objectO等于new objectject。然后呢，我第二句话呢，我调用了另外一个方法，这个方法叫M。

在内存里面到底是怎么运行的呢？听我说，这就是这个进程里面的一个结构。这个进程里面结构什么样的呢？首先第一点，object O等于new objectject，这里面有两个东西，第一个是这个变量。

这个小O这小O在哪儿呢？它是位于我们的栈空间。好，这里叫做站。只要是冯诺伊曼结构的这样的一个程序。我告诉你啊，它结构都一样的，这里叫做站站是什么意思呢？占站嘛，如果你稍微学过一点数据结构。

就是先进后出先进去的后出来后进去的先出来，它是这样一种数据结构。你可以认为它就是一个桶。你先把这个馒头扔到桶底下去的，你能拿的时候，得先把上面的拿出来，最后一个才能拿出来。好，这是这个占空间。

在占空间里面。首先呢会有一个战争出现，这个战争是谁呢？任何一个方法出现的时候都会有一个战争。任何一个方法都会有一个战争。OK媚方法媚函数。既然是调用 may函数，那么首先在栈里面会形成一个战针。

战针它的英文呢叫st frame。这叫做基于栈的这样的一个一个一个结构啊。其实除了基于栈的结构之外呢，还有基于呃别的的结构。但是基于栈的结构啊，还有基于寄存器的结构。

基于站的结构呢是最常用最简单的、最简洁的java呢就采用了这样的结构。这个程序开始执行，会形成会有一个战产生。注意这个站呢。一个县城一个站。每县城一个啊。是。你看啊当我们呃程序开始运行的时候。

这是我们的主线程了。我们主线程呢就会维护一个数据结构。这个数据结构呢就是一个站。在这个站里面呢，它呃会生成这样的一个呃方法的调用。方法的调用路径。这调用呢首先会生成我们的妹方法的栈。当然。

 MA方法的站放到站里面之后呢，叫一个战针，一个方法对应一个战帧。如果说你比方说在没方法执行到某一句话的时候，假如说呢它是执行到这里了。没办法执行到这里的时候，他调用了另外一个方法，这时候会怎么办呢？

会在这里暂停，然后跳到M方法里面去运行。😊，当然这个M方法呃，怎么运行呢？实际上就形成另外一个。战争就是这个M战争，然后指令放在哪儿呢？指令永远放在最上面啊，该执行哪条指令了，把这个指令呢给拎出去是吧？

然后它还有一个非常重要特点，什么样特点呢？就是如果一个方法执行结束了，比如说我M方法调用完了，M方法执行结束了或者没方法执行结束了。它会把它给弹出去，所弹出去是一个形象化的说法。

其实呢就是把站顶指针往下移动就可以了。站顶指针往下移动。站顶指针往下移动，CPU要找的时候呢，就会从下面开始找了，就不会找上面上面就废掉了，所以这是这样的一个特点，不知道我说清楚没有。这很简单啊。

你稍微有一点那个计算机基础的话呢，一说你就应该明白。所以如果这句话object order等于于object，它会首先在这个战争里manin这个战争里面生成一个小O。注意这是那个小O。

但是我们扭出来object放哪呢？就是如果说这是我们弄出来的 objectject，它是放在了我们的堆里面。这是堆空间。所以堆空间是在程序执行的时候，用来动态分配内容的空间。

OK然后这哥俩之间呢建了一个关联，这个小O通过这个小O可以指向谬出来这个对象。好了，这是大体的战和堆的最基本的概念。那有同学可能就会说了，老师，你这你讲这个是要不是讲GC的吗？怎么突然开始讲这玩意儿？

因为这东西啊跟GC的发展呢叫做息息相关。好，我讲到这，大家还能跟上吗？没问题的给老师扣个一，稍微做一下总结，就是每一个县城都会维护自己的县城站。县城站里面放着的是一个一个方法调用。

调用的路径的一个战争的堆叠啊，就是一堆战争啊，M方法掉了没方法调了MM呢，如果再调一个方法，它就在上面再形成一个战争。什么时候这方法调用结束了怎么办？倍儿往外一弹。😊，所以有同学说了，老师。

那这两个有什么区别吗？还是听我讲。😊，嗯嗯。好好，听我讲。老师呃，这个站和堆有有什么区别吗？这里面最重要的一个区别是什么呢？最重要的其一个区别是我不知道大家发现没有作为站空间。

当你占用了站里面空间的时候，它是自动释放的。😊，ok。我再说一遍。作为站里面的空间，它是自动释放的。占空间是自动释放，为什么叫自动释放啊？方法已结束，战争。顶针儿啊顶上那个格就往下移。

你得找下一个继续往下运行的那个地儿去，你得跑到下一个战争空间里面了。所以上面那个战争空间就废了，直接就废了。自动释放有什么好处呢？就是如果你有一些。空间是分配在这里的话，你在这里面占的地儿。没关系。

你不不需要手工释放它，你发现没有？你只需要说这方法一结束，哎，哎哎他就弹出去就就没有了。所以你发现没有？像这个这块空间，虽然说它也占一块空间。😊，但是呢你不用手工去释放它。没必要去释望呢，什么时候失望。

没方款一结束啊，整个就往外一弹就结束了。但是堆不一样，堆是什么？堆是在你执行过程之中自己手工溜出来的。缪出来了之后就会战生产生一个空间啊。占了一块地方，你发现没有？那好。

如果说你这个程序里头不停的扭一个fer循环，不停的往里扭扭扭扭扭扭扭扭扭扭扭扭扭扭扭，你发现没有？有一个很重要的问题，很严重的问题，这哥们儿很快这个空间就没了。是不是早晚就没了，是吧？同学们。😊。

那现在的问题是你怎么去管理这块空间？占空间很简单，只要是方法一结束。好，所有的站的空间就全弹出去就没就没有了。你不用管特别简单，但是堆空间不行，堆空间是你要往里头分配，但是你得负责把它给回收。

回收的意思是什么意思呢？回收的意思就是把这块空间标记成为。可用了。原来呢是你是站着的，被别人给占住了，不能让别人用，比其他程序不能用，其他的语句不能用，其他线程不能用。但是。

你必须得手工的来进行对它进行管理。什么时候呢？你觉得我用不着这个对象了，你就要把它给删掉，删掉的就是做个标记。这这块空间已经可以用了，已经让出来了。不知道说清楚没有？好。

听我说我这个讲的东西呢跟任何的语言呢没有关系，跟语言没关系。任何语言。任何语言再强调一遍。从诞生到现在为止的所有语言。都会面临的一个问题，就是这块空间我该怎么去释放它。我告诉你。

程序之中最难调试的bug就来源于这里。程序之中最难调试的bug，一个是野指针，一个是并发问题。这两大问题是程序之中最最难于调试的bug。好，解释一下什么叫野指针。野指真的意思是很简单。同一个对象。

释放了两次。好，这是什么意思？不能说呃sorry。不能说释放了两次。就是同一个对象。嗯。同一个对象。😔，两个指针，一个释放了。另外一个不知道啊。还拿来用嗯。或者说虽然说同一个对象是是可能是同一个指针。

或者说是同一个指针。不同位置。其中一个其这个对象已经释放了，但是另外一个指针的另外一个位置的指针不知道，另外一个县城里面的指针不知道。好，它依然还在使用，这个是也指针，就是不再指向任何对象的指针。

这就是著名的，有一个异常叫no。Poiner exception。呃，如果你原来学过C语言，CI加语言，经常的这种东西会引起内存的崩溃。我告诉你，这是所有语言所面临的最难调试的bug，包括java。

这个东西是怎么产生的呢？非常简单，给大家看张看张图。我给大家再稍微画一下。再看这里简化一下。同学们听我说。呃，我不管你是任何的语言。😊，假如说我们有两个指针，跟rC跟rV。嗯。好。掉高了。嗝屁吧。去。

嗯嗯。😊，好，看这里，假如这个O和这个P，这俩哥们儿呢同时指向的是同一个对象。那么如果我们程序执行的时候，比方说我在ma方法里面要把这个对象给干掉了。或者我的M方法里面把这个对象给干掉了，给它删了。

那我问你没方方面的这个小O，它指向的是个什么东西啊？纸箱的什么东西，加个就叫地址，没有指针，加个叫引用，本质上就是指针。好吧，我们谈本质啊。不要谈那个那个那个你你不要咬文嚼字，你不要学孔乙己。

非得跟我矫情回字有4种写法。这个东西没意义，理解什么意思就行。好吧，玩文字游戏是最没劲的嗯。这时候这时候就变成空指了，对不对？更有甚者，你这块删了之后，被别人给占了，你想想看会发生什么会发生。

你指向了别人的对象，也许你操纵。我告诉你，你拿到了别人的这块内存里面的东西。以前啊在内存里面偷别人密码，就是这么干的。嗯，好好听我说，这是程序史上最难调试的bug，就是野指针。

这个指针指向了它不该指向的东西，它特别严。这有这个就叫野指针，不知道我说清楚没有？嗯，C和C加加里面呢是永远你要面临这个问题的。也许一不小心你这边删了，另外一个指针还在使用它。

也许你这不小心这边删了其他的程序，或者说其他的程序的部分内容又又又又占用了这块空间了。那么这时候你另外一个指针指向了它不该指向的内容。好了。我现在并没有聊java语言，我现在聊的是所有语言。

就是无论是什么什么语言都要面临这个问题。你要正确的删除这块空间，不能多删一次，也不能不删。还得保证你删完之后，所有人都用不了。好吧。这是非常非常难的啊。我告诉你，这是第一这是第一种特别难调试的bug。

历史上这种bug呢维护起来超级超级难。你知道go语言是怎么诞生的？go语言是原来google为了替代他们以前写过的好多C语言的程序。C语言程序呢写起来也许比较容易，但是维护起来超级麻烦。

bug调试起来特别特别困难，所以他们开发了go语言。go语言呢不再用手工的方式去维护这些内存空间啊，而是调也跟java一样啊，引入了GC。当然这是最难调试的bug之一。

那么第二个最难调试的bug是并发问题，我觉得这个问题稍微一说，你就明白，就是多线程。访问。同一块儿。那种公园。如果这个并发问题，再加上野指针问题结合起来的话，你调试起来就更麻烦了。这里只是一个县城站。

完全有可能我还来另外。另外的一两个。这个是非常有可能的。你想想看。嗯。😊，行了，这个图不太好画啊。😊，这这图呢不太好画。缩小一点儿。给哥们放这边了。完全有可能发生一种什么情况，我这个县成站里面啊。

也有好多好多的指针。好，我指向了这个对象。也许是我这个线程把这对象给删了。也许是我这个线程访问的时候，我俩同时开始写，造成了数据的不一致。好了，我告诉你，像这样的问题调试起来是最最头疼最麻烦的。

不知道大家有没有这方面体会。当然有同学说，老师，我天天写CRUD我是没有这方面体会的，那就没招了，这也是为什么你呃你你你你你你你不应该不能过只关注CRUD的原因。

因为面试里面好多好多的问题都要牵扯到这方面问题了。好吧。
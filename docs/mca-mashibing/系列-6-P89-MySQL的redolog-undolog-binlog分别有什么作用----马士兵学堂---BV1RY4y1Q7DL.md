# 系列 6：P89：MySQL的redolog、undolog、binlog分别有什么作用？ - 马士兵学堂 - BV1RY4y1Q7DL

刚说的东西，假设两个日志啊，我明确了都要记住，我如果先写redo log进行，然后再写blog对吧，建议大家写写他这样两个方式，如果再这样写的话，这里面会有一个问题，同学们听好了，什么问题。

如果我写完redo log之后，突然啊写完do log还没来得及写vlog的时候，我突然断电了，这时候会发生什么情况，解压，当写完redo log没有写完blog的时候，会有什么情况发生。

你觉得会有什么情况发生，注意啊，我的revlog里面写完了，写完之后，我一定会把它一写到我们磁盘里面，就算我在一写磁盘的时候突然断电了，我的road log里面只要有数据或只要有对应的记录。

那么我是可以根据redo log来进行重启的，但是你要考虑一件事，你写完的redo log，你的blog里面是不记录对应信息的，那这个时候假设你有两台机器，a的操作，a机器和a服务a数据库是吧。

然后b数据库，是通过什么blog来进行数据同步的，此时你考虑清楚了，当他写完了，他没写完，你的b数据库在同步数据的时候，会不会代表这一条数据会反而不会，对位，不会如果不会的话，就会出现一种情况。

什么情况，你的a数据库里面已经做完了这条更新操作，但是你把blog同步到b机器的时候，你的b机器里面并没有这个操作，你告诉我你ab两个机器里面数据还一致吗，一致位置了，不一致了吧，那不一致。

你的主从同步不就失败了吗，不就存在对应的一个问题了吗，是不是这意思啊，所以它是不可以的，不能先写日志log再写blog，那其实反过来道理也是一样的，如果我先写了blog，然后后面我再写我的logo。

这种情况一样的吧，什么叫一样的，想好了，我先写完blog，然后没有写完redo log，这时候是什么情况，你blog里面记录了对应数据，blog记录了对应的数据，是b机器，我b服务器b已经将数据同步。

但是redo都没有，此时如果出现了凡是safe，或者说如果出现了断电，出现断电之后，你告诉我，你能够根据blog把数据给恢复回去吗，这个问题啊，你当你断电之后，你能够把你根据blog把数据给恢复回去吗。

能不能，不能吧，你连数据嘛肯定会受不了，他恢复不了，意味着a g g是a的，数据是有问题的，少一条，但是你的blog已经同步到b机器里面了，b机器里面是不是会多一条记录或多一个操作。

此时你的ab两个里面的数据还一致吗，一致位置，这又不一致了吗，是不是这意思啊，所以不管你先写日blog还是先写blog，它都是有问题的啊，所以这种机制有问题，因此才诞生了，我刚刚给大家展示的东西。

什么呢，叫两阶段提交，什么意思，我先写redo log，只不过此时我的redo log，它处于的是叫prepare这个状态，然后我再写blog，当我把blog写完之后，我事务提交了。

我再把我们的redo log置为commit状态，那在整个这个执行过程中，依然在任何步骤的时候，都有可能会出现断电情况，比如说这儿如果断电了，可以了，听好了，这如果断电了，当这断电之后。

我需要做什么判断它的运行机制是这样的，听好了，如果在此处出现断电了，那我在恢复的时候，我会先检测我的revlog，我只do log里面状态，我简称log之后发现当前的relog属于普片状态。

当它处于普片状态之后，我再去blog里面找对应的数据，比如blog里面是否同步记录了与之相同的操作，如果有，如果有，那么此时把刚刚review里的prepare状态，改成commit状态，如果没有的话。

干什么事，把刚刚redo log里面的prefer，这条日志直接置为失效，我直接认为无效数据，这样的话，我的real log和我们的blog能不能保持保持数据一致，可以吗，这是刚刚这个断电的过程。

那样吧，在下面这个步骤里面，它也很不断电，当它断片之后一样逻辑，我先找一个log，我一找诶，发现一个log里面有图片状态的数据，这时候我在找blog里面找，我一找blog。

blog里面是不是有对应的记录，有对应记录怎么办，把刚刚的prepare状态的数据改成commit状态，这样的话两条数据记录都保持了完全一致，所以不管你依靠哪个数据来进行，数据恢复的时候。

他都不会出现数据的不一致性的问题，这东西就称之为叫两阶段提交，这东西p班同学给老师扣一，能听懂吗，所以啊这东西在面试中也会经常被问到，你要给面试官把这东西给讲清楚，它对应它对应的东西。

老师redo和blog pupa团队的方式能替换吗，不可以，因为blog他没有prepare这样一个状态，blog没有prepare这样一个状态，没有prepare一个状态好吧。

所以他不可以互换位置好了，这个两阶段提交这东西我做了这么多，所以当提到这个logo的时候，你要把blog整合起来，了解一下它的两阶段提交就可以了，vlog在sl单链中还有吗，它是持久化到磁盘的。

怎么会没有呢，它是持久化到磁盘的，所以一定是有的，注意断电之后数据丢失的话，只会把内存里面的数据也丢失掉，你磁盘里面的数据是不会发生丢失的，所以不用担心这件事儿，好吧好了，刚刚我解释了原子性。

通过undo log来实现隔离性，通过mv c c加锁来实现持久性，通过relog来实现，但是我唯独没有提一个东西，就是我们的一致性，这里面我要强调一件事，同学们听好了，这里面我们写一句话，记住了。

为什么一致性没有写具体的实现方式，这边有很重要的一句话，一致性是我们根本的追求，一致性是实现，方式是由其他三个特点来保证的，明白意思，也就是说它没有什么具体的实现点，其他三个特征共同保证了我们的一致性。

问题来这儿能听懂，同学扣一能听懂吗，赶快记一点好不好，当这些问题都聊完了之后，下面我们进入到一个环节，什么环节，我们就要讲一下我们的mv c c这玩意儿啊，重点聊一下m c的这玩意儿。

m c c坦白说还是有那么一丢丢复杂的，好同学在了解m c c的时候，其实怎么说理解的都有多少有点有失偏颇，那今天我们重点把nv acc对应的实现机制，给大家讲清楚啊。

m v c这玩意儿m c刚刚不是多多，我都说过了啊，现在了解奥特fm v c c刚刚解释过了啊，什么叫mvc c，它的翻译是什么线程锁吗，不是跟县城所没有关门的关系，它叫做什么叫多版本并发啊。

这它对应的一个全称啊，既然涉及到并发了，那这里面会有一个问题，同学们数据库里面的并发大概分几种情况，听好了，数据库里面的并发大概分几种情况，这是什么，有多个事物在进行同时操作的时候，有几种情况。

三种哪三种啊，第一种叫读读是吧，第二种叫读写好，第三种叫写写，这都是我们产生这种并发读取的时候，要产生的一些操作，比如说同时读都是读还是都是写，还是有读有写啊，这样的一个这样三种情况。

那这样的情况我们要解决问题什么问题，这三种情况在进行并发操作的时候，它会有对应的问题吗，比如第一个读读会有数据安全问题吗，他需要进行并发控制吗，需不需要不需要不存在任何问题，也不需要并发控制。

因为你在进行数据读取的时候，它并没有实际的改变我们的数据值吧，所以不需要了是吧，那第二个读写会有问题吗，有吧有数据安全问题，幻读不可重复读啊，都是这种各种机制里面它要存在的一个问题啊，这东西还有第三个。

写写写写会有问题吗，有没有有有数据安全问题啊，可能存在丢失而叫更新丢失问题，就说是存在这些对应的一些情况的，当存在这些对应情况之后，我们总要考虑解决方案，对不对，在考虑解决方案的时候。

你就想什么解决方案，最普通的方式我可以通过锁的机制来实现吧，比如说加速锁是可以解决这个问题的，但是我在使用锁的时候，明显有一个问题是什么，效率低吧，是不是效率低啊，那如果我想保证我的效率足够高。

我应该怎么办，怎么做，换图的问题，一会来解释，别着急好吧，锁它的效率一定是很低的，但是这个时候你可以联想一下，你之前在java那种并发编程的时候，java里面在进行并发编程的时候。

你除了可以加那种cd带子这样的一些锁之外，还可以干什么事，好了，话费提成说的一个东西叫c a s cs叫什么，叫compare and sweep，其实我们的mv cc类似于这样的机制。

就是说他不需要去进行加锁，当然在mc里面它并不是进行对比的，只不过它减少了我们所对应的一些存在的问题，就是说它是用来解决加锁这样一个问题的，明白意思吧，跟cs不一样，但类似的机制是一样的。

类似的机制是一样的，那到底它怎么实现呢，实现的方式非常简单，刚刚有些同学提到了格林级别，隔离级别的东西，我希望同学们能够一会儿再聊，我们一会再聊隔离级别相关的问题，先扔一边。

等需要聊的时候再来隔离一边不需要聊，先不聊它好，在讲mv c c对应的实现原理之前，我需要同学们先具备两个最基础的概念，第一个概念叫什么叫当前读，第二个概念叫快照读，比如说你必须要把这两个名词搞清楚。

什么叫当前读对了是啥意思啊，是不是当前读记住了，所谓的当前读，表达的意思是说在进行数据读取的时候，读取的都是最新的版本数据，记住啊，这最新的版本数据啊，而且在读取的时候，还要保证其他并发事务不能够修改。

我们当前的这些记录，会对我们读取的机构进行加锁操作，这叫当前读，除了当前组之外，还有第二个概念，叫什么叫快照读，那什么叫快照读啊，一个人读最新的数据，那快要读读啥，读什么，对读取的是历史版本的数据啊。

是有可能读取到对应的历史版本数据的，好吧，那这里面会有一个问题，老师什么样的操作会触发当前读，什么样的操作会触发快照读呢，注意了，这样说明一下，我们当前读触发操作有以下几个，写一下，第一个。

比如说sl lock in shell model，什么意思，加读锁吧，比如说select for update加解锁吧，比如说我们执行的update操作对吧，d类的操作对吧，包括音色的操作。

像这些操作在进行操作的时候，都都都基本上都是当前读光线图，它变成快照读，那什么时候会触发我们的快照读呢，也非常简单，它有且仅有一个什么东西呢，叫select，注意。

最普通的select有可能触发的是我们的快到数据，而不是我们最新的数据，有人有这样的感受吗，就你读到的数据是旧的数据，有人这样的感受吗，你之前在操作数据库的时候，有读到过旧的数据吗，有没有。

想想回忆一下有没有，如果你说没有，那么我就要给大家举例子了，好如果你说没有调举例子了，橘子来看一下它到底是什么样的一个情况。



![](img/9a108a593ebf915492203f2cd7b88ce8_1.png)

已经算相，但还是旧的，是这样的情况，来看好这个例子啊。

![](img/9a108a593ebf915492203f2cd7b88ce8_3.png)

下面我来举例子说明了还是一样，我们不可能光讲理论知识，还是要带点实操的好吧，let's go，boa杠p，我来演示一个场景。



![](img/9a108a593ebf915492203f2cd7b88ce8_5.png)

你来告诉我对应的关掉了，我来演示一个场景。

![](img/9a108a593ebf915492203f2cd7b88ce8_7.png)

你来告诉我，对应的答案和对应的效果分别是什么，认为很重要好吧。

![](img/9a108a593ebf915492203f2cd7b88ce8_9.png)

来了两个窗口同时进来。

![](img/9a108a593ebf915492203f2cd7b88ce8_11.png)

mexico杠u root杠p123456 。

![](img/9a108a593ebf915492203f2cd7b88ce8_13.png)

进来进来之后，我们use demo这个数据库，然后呢在里面我去创建一张表，grade table ut 18连接方案。



![](img/9a108a593ebf915492203f2cd7b88ce8_15.png)

90的id int primark。

![](img/9a108a593ebf915492203f2cd7b88ce8_17.png)

内部卧槽。

![](img/9a108a593ebf915492203f2cd7b88ce8_19.png)

![](img/9a108a593ebf915492203f2cd7b88ce8_20.png)

这个sql已经足够简单吧，我觉得这个sql语句有人看不懂吗。

![](img/9a108a593ebf915492203f2cd7b88ce8_22.png)

没有吧，足够简单了啊，然后insert into t18 values。

![](img/9a108a593ebf915492203f2cd7b88ce8_24.png)

![](img/9a108a593ebf915492203f2cd7b88ce8_25.png)

写这个值一根号一。

![](img/9a108a593ebf915492203f2cd7b88ce8_27.png)

![](img/9a108a593ebf915492203f2cd7b88ce8_28.png)

三好了，往里面插入了三条，结果三大将from t18 没问题吧。

![](img/9a108a593ebf915492203f2cd7b88ce8_30.png)

这边也是一样的，select。

![](img/9a108a593ebf915492203f2cd7b88ce8_32.png)

七from 718。

![](img/9a108a593ebf915492203f2cd7b88ce8_34.png)

两边数据一样不一样，告诉我两边数据是否一致，一样吧，没有任何的一个区别好吧，下面我要做一些最基本的操作了，第一个操作是干嘛，我们为了模拟事物的一个执行过程，或者执行情况。

我需要把自动提交事务的按钮给关闭掉，所以叫set auto commit等于零走。

![](img/9a108a593ebf915492203f2cd7b88ce8_36.png)

![](img/9a108a593ebf915492203f2cd7b88ce8_37.png)

然后commit一下，我现在把事务自动提交给关闭掉了，当我关闭掉之后，我为了模拟两个事物，a b是两两个，这是两个窗口，一个a一个b，那么我能不能手动的去开启我们的事物啊，我能主动开启事务吗，可以吧。

两种方式，第一种start的反击是第二个begin。

![](img/9a108a593ebf915492203f2cd7b88ce8_39.png)

我依然执行begin操作，当我开启事务之后，我的问题来了，同学们，现在我开启了一个新的事物，两边数据是否一致，你这个意思你知道吧，这个没啥问题啊，肯定是一致的，如果一致的话，我们就要考虑一件事。

我在第二个窗口里面，我做一个up不对的操作，比如update t18 set name等于连，然后结束，我现在更新完成之后，两边的数据是否还一致，现在一样吗，有人会说老师应该不一样吧，为什么。

因为你从右边窗口里面是我没提交，我现在把它给提交掉，我的问题听好了，问题来了，当我这边提交完成之后，我在这边进行数据的查询，我查询到的是零还是123，告诉我零还是123，来各抒己见好吧，翻翻你们的看法。

好了，有说连的，有说123的，但是我看到的情况是123的，情况应该是偏多的，但是实际查询起来你的结果它是连，并不是123，还有刘娜说，老师要看隔离级别，这块跟隔离级跟隔离级别没有半毛钱关系。

没有半毛钱关系，我先问一下我们当前的隔离级别，mysql默认的隔离级别是什么，什么查一下嘛，flat at concision，什么repeatable read，因为我从来没有改变过合理的级别。

所以别的级别是一模一样的。

![](img/9a108a593ebf915492203f2cd7b88ce8_41.png)

没有任何一个区别，这样你首先要记住了，好吧，先把这个记住来，现在我把两边的事物全部提交掉，commit我在演示另外一种情况，看好了另外一种情况，什么情况，我现在都commit掉了。

我同时再开启我们的事物，开启之后我看一下我们的数据，三星和t18 ，现在数一样吗，现数是一样的一样吧，一模一样，隔离级别我也没动过，我依然在第二个窗口里面，我做一个更新操作，update t18 。

set name等于合合的走，我一样在提交，我现在读取到的结果是123还是连，什么，连是吧，失联了失联唉，为什么，为什么在刚刚这里面的时候，我就可以读到最新的数据，为什么在这的时候我就读不到最新数据了。

听好在我第一次演示的时候，它是可以读到最新的数据的，修改之后的数据，但在第二次的时候。

![](img/9a108a593ebf915492203f2cd7b88ce8_43.png)

我就读取不到修改之后的数据了，你在这边进行查询的话，他已经改了，他的数据明显就不一致了，小福利说数据库bug，怎么可能数据库bug。



![](img/9a108a593ebf915492203f2cd7b88ce8_45.png)

这里面其实涉及到的就是当前读和快照，读的问题，跟缓存没有半毛钱关系，这也是mv c c它存在的一个重要的原理，重要的点好吧对，区分点是什么，是我在读取之前，我进行了一次查询操作。

为什么我执行一次查询操作之后，就能够达到当前的事物，但是达达当前实现效果了，原因是什么，这个原因在于mv c c。



![](img/9a108a593ebf915492203f2cd7b88ce8_47.png)

在下面我要详细的去讲一下，mv c c具体的实现机制。

![](img/9a108a593ebf915492203f2cd7b88ce8_49.png)

你准备好了吗，想搞明白刚刚为什么会出现这种情况吗。

![](img/9a108a593ebf915492203f2cd7b88ce8_51.png)

为什么我多执行了一次查询操作之后，两次结果就不一样了，来想知道的扣一请结一下自己好吧。

![](img/9a108a593ebf915492203f2cd7b88ce8_53.png)

![](img/9a108a593ebf915492203f2cd7b88ce8_54.png)

这时候核心点和重点来了，来先说m c c m c c在进行底层实现的时候。

![](img/9a108a593ebf915492203f2cd7b88ce8_56.png)

它总共包含了三部分操作，第一部分叫什么叫隐藏字段，什么叫永恒之断，也就是说，在我们的m v c c进行实际操作的时候，他其实除了我们看到的字段之外，会包含一些包含一些我们看不到的字段，看完自然有几个呢。

有很多这块我重点说三个，第一个什么叫db下划线，t r x下划线a b这是第一个隐藏字段，它要表述的我看表示什么意思呢，其实非常简单啊，表示什么叫自创建这条记录啊，或者最后一次修改该记录的事务id。

这是第一个字段要表示的意思，还有第二个隐藏字段叫什么叫db下划线，roll下划线p t2 ，他表示什么意思，它叫做，做完了这个回滚指针好吧，指向数据的上一个版本，上一版本都一样的。

还包含第三个字段叫db下划线，我昨天说过的东西叫roid吗，什么意思啊。
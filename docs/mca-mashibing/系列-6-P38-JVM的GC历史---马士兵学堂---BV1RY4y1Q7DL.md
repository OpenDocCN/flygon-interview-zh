# 系列 6：P38：JVM的GC历史 - 马士兵学堂 - BV1RY4y1Q7DL

rust有啥缺点，rust缺点就是学习曲线居高嘛，特别高，好同学们讲太多了是吧，嗯已经九点了，what确实是啊，我们来聊聊那个jm的gc的历史啊，疲惫了是吧，嗯a了，已经疲惫了，不会吧，你们还活着吗。

我们可以继续吗，这还没开始dc呢，没开始就没开始吧，就业咋样，就业不怎么样，因为rust刚刚发展，我们静观其变，我是喜欢让我们自己的学员，都站在业界的最前沿，就是你要抬起头来看看整个行业发展。

站在整个业界最前沿，你就能发现更更加优秀的机会，发展机会的时候，你能扑上去啊，做好准备，好看这里我们来聊聊gm的dc的历史啊，就这块的内容呢，我稍微补一点最基本的这种技术上的概念，我们先来说呢。

到底什么是一个垃圾，就是我们刚才说嘛，如果是你呃，采用这种引进垃圾回收器的，这样的一些个语言的话，那你你总得找出来，就是业务线程在这里不停的扔线团，扔线团，扔线团。

线头和线条之间的有各种各样的线来进行关联，好作为垃圾回收线程的角度来说，我得去定位啊，这这这这到底哪个是垃圾，哪个线程是垃圾啊，怎么找啊，这里面的找法呢一共有两种啊，这什么是垃圾，我们先定义什么是垃圾。

这垃圾呢其实很简单，就是你看这你看下面这个对象，这个对象呢在运行的过程中，没有任何引用指向它了，原来的一个成员变量的引用指向它现在没有了，好这哥们就是垃圾是肯定的，没有人没有引用指向它的，好。

它就是垃圾，但是我们怎么定位这个垃圾呢，定位这个垃圾的话有两种方式，第一种呢就是reference count，你看一下，看一下动画就理解，就这个对象呢，我给他做一个计数引用计数法，这叫有三个。

目前有三个引用指向我，我脑袋脑门上写了一三啊，接下来如果有一个已经消失了，变成二，有一些用消失变成一，有一个消失变成零，当它变成零的时候，这哥们儿成为垃圾，python就是使用这样的方式。

这个叫引用计数法，引用计数法有毛病，毛病在于哪呢，我们假如说有一堆垃圾，三个垃圾a指向b b指向c，c又指向a好，所有的对象都有引用指向，但是没有任何其他的引用指向，这三个对象中的任何一个啊。

这叫做三个垃圾，一堆垃圾，一坨垃圾，那么像这样的话，如果你用reference count的方式就找不出来，因此java里面采用的并不是这种方式，怎么定位一个垃圾，java里面采用的是这种方式。

叫做根可达算法，叫做research，这算法一说你就明白根可达算法的意思是，我们从根儿上开始，什么叫根may函数里面，简单理解may函数里面的一个一个变量，这就是根儿就没函数，通过这根线来跟着捋。

捋到谁谁就不是垃圾，它的成员变量又指向了它，它的成员变量又指向它，又指向它，又指向它，好，这几个全部是垃圾，顺着这根线找，找不到谁的时候，树的搜索算法找不到的，这些全是垃圾，这个大家能听明白吗。

有没有同学有疑问的，循环引用不能把引用断开吗，人家业务逻辑就要循环引用，你为什么要给人断开，你断开人家业务逻辑不变了吗，大哥，当然大厂面试的时候呢，有一个问题叫做什么是根儿啊，如果要讲这些细节的话。

我我倾向于讲东西呢是先从很高的层面来讲呃，我建议大家学东西，学学课程也是一定是要什么呢，先建立知识体系，这件事情超级重要，有很多人呢连最基本的学习方法都不会，可以说啊，从小学到大学学了这么多年。

最基本的学习方法没学会，一定要先建立知识体系，然后再去查漏补缺，我讲的再形象一点，你掌握一棵知识树的时候，先把树干给我掌握了，然后再去掌握树枝儿，然后再去找我书页，你的树干和树枝子。

你看你的树干只要是特别稳固的话，你树叶想刮多少刮多少，现在很多的碎片化的学习，都是让你掌握书页的知识，你掌握了多少书页都没有用，因为你没有建立整个树干的体系，了解一个庐山，你得坐着飞机从上空飞过。

看庐山的整个面貌，而不是说你到庐山脚下某一棵树底下，去研究庐山的蚂蚁窝，这种纯属扯淡，听我说我上了这么多年学，我记得我上大学的时候，有一个学期把清华图书馆所有的物理书，那藏书很多的啊，大概得有几万本一。

一个学期我全把它全把它看完了，当然没记得多少，但是整个物理的体系慢慢就建立起来了，呃小伙伴们，你们呢如果不同意这个说法的话，我不管你同意不同意，你采用一下，你试试看，就知道要先要先建立知识体系。

听懂了吗，建立知识体系之后，再去研究那些细节好吧，知识体系的建立呢就是囫囵吞枣，四个字叫囫囵吞枣，有好多人学东西啊，特别好玩呃，他在学习的过程中，假如说这是一棵知识树嗯，他在学习的过程中。

他学到某个节点的时候，它会顺着啊，就每一个细节，比如说别人给他讲dos窗口，你怎么设置环境变量啊，咱们学java的人一般都会遇上是吧，怎么设置环境变量，怎么设置pass class pass。

他就开始研究哇，这dos挺好玩的啊，这dos还能写b a t这这这这个b点，这这脚本语言的啊，我研究研究这个脚本语言怎么玩吧，然后啊这道德窗口怎么产生的呢，研究显卡行行行行，哎呦哎玩玩ps，我跟你说。

完蛋，你要这么学，你的时间就全部浪费，没有用，而是你应该怎么学呢，先二话不说，把整个这些关键的点全拿下，拿下之后呢，再去发散，再去纠细节，我大概就是这意思好吧，嗯那就是想先看完本书呗，行行行。

你这个理解能力我也是醉了，看来我还是我表达不够啊，sorry，好我讲到这儿呢，我是希望大家呢先把这个什么是根，这件事呢先略过，不要着急，因为如果作为，呃官方的非常规范的定义来说，你得去看哪本书呢。

叫jvm，叫java virtual machine specification，那这本书呢是在oracle网站上可以下载，它的全称叫做jvm的虚拟机规范规范大哥，他很枯燥的。

也只有像老师这样特别无聊的人才会去读他，其他人你不用读，所以根来说这本书上给你说的非常明确，它包括这么几部分内容，jvm stack的内容，stack jan native method stack。

又是jan runtime constant prove，运行时常量常量池，steady reference in method area，方法区里面的静态引用，以及我们的class类的对象。

这里面的任何一个拿出来，你不了解jvm底层，直接就把你给看晕了，所以你不用管根嘛，我给你举个最简单例子就行了嘛，main方法里面的有一句话叫object小o等于new object，好。

这哥们就是格听懂了吗，很简单，就是方法整个程序开始执行的地方，最先建立起来的那些对象，这些哥们儿叫歌叫root，专业说它就是gm stack里面的内容，stack站里面的。

我们那边方法里面不是为我们县城站吗，主线程站，对不对，这里面对象get了吗，好我们可以继续吗，先把它略过好不好，所以从根上开始找，本意就是从根上开始找，反正是顺着根儿捋捋捋。

就是我我还是喜欢讲的稍微形象一点啊，形象一点就是你比方说你嗯，你女朋友，你男朋友啊，你们哥仨，你们姐仨啊，甭管是哥仨姐仨，在一个空间里面，内存里面扔小线团，谁是根儿啊，你们仨就是根儿。

你们的手捋着这个小线团，捋到的全都不是垃圾，凡是捋不到的，中间那个线给断了的，全都是垃圾，就这意思，这样的话呢，你就不会给产，就是那种原来像这种互相引用的，但是哎你顺着根，只要找不着他，这根俩就是垃圾。

知道吧，这是第二种算法，叫根可达，非常简单啊，当我们知道了什么是垃圾，当我们定位了什么是垃圾，定位好了之后呢，我们要把它给清掉，对不对，好清除算法从上个世纪60年代开始发明的，到现在为止，几十年过去了。

就这三种清除算法，就这三种，这三种是啥呢，第一种叫mark swift，第二种叫copy，三种叫mark contact，背包就行了，特别简单，仔细看，第一种叫mark sweep，就是我找到了标记标。

把它标记成为垃圾之后，把它给清掉，就这么简，原来ok这哥们是垃圾了，怎么办，打上个标记，说这块空间可用了，可以可以使用了，后面的人可以在这里面分配内存了，搞定，梦洁说什么情况，根部可达，没想出来。

我的老天爷呀，梦洁你是玩语言的吗，object o等于new object好，这里有个小o指向它，我写o等于空来，你告诉我这个o指向谁，这个引用还有没有，贝儿，让我忍住怒火，继续给你们往下讲。

开个玩笑啊，嗯总是有2年没睡了，开玩笑开玩笑啊，我们回一回的气氛，听课听着怪累的，稍微聊会儿，小甜甜k好，我们来看这个标记清除啊，要清楚的意思就是诶我们简单说吧，我们顺着根开始找，找到的全都不是垃圾。

这些找不着的全是垃圾，怎么办，把它们清掉，哎，这就叫标记清除，简单吧，就这么简单嗯，找到的这些全都不是垃圾，没找到这些全是垃圾，怎么办，清掉咔嚓咔嚓清掉好标记，清楚标，清除这种算法嗯，虽然说比较简单。

但是有它的毛病，毛病在哪呢，当我们好多好多次运行，运行很长时间之后，你会发现这也有清掉的部分，这也有清掉的部分，这也有清掉的部分，这也有清掉的部分，你会发现你的内存变成了碎片化，特别严重。

碎片有好多有好多洞，然后这时候你要是想来了一块大的空间，我想分配下去，你发现你找不着了啊，碎片化特别严重，好嘞，当然呃，第二种算法没有碎片化，但是也有它的毛病，第二种算法叫拷贝，拷贝也特别简单啊。

认真看，其实啊就很简单，不管你们家多大，你们仨只能用一半，你女朋友你男朋友好，在里边玩吧，随便玩随便折腾，折腾完了之后呢，我的垃圾回收器进来了啊，你妈妈拎着一把笤帚就进来了，他进来之后干了一件什么事呢。

顺着你们仨开始这根开始找找找找，找出来的东西，整体性的全都复制到另外一半里面去复制过来，同时排列好，看到了原来那个没排列好的哎，都给它排列好，然后把左边这半边整体性的全部回收，ok这个算法也简单。

效率越高，但是我相信你那大腿想一想，也应该知道他的毛病之所在，还用我说吗，浪费内存，没问题吧，很简单啊，我们在聊第三种叫my compact，my comment，什么意思啊，这就更简单了。

就是既然第一种呢碎片，第二种呢浪费内存，干脆呢我就在回收的时候直接把它整理好，什么意思，再说一下你你女朋友，你男朋友好扔小线团，然后运行的过程之中呢，产生了各种各样的垃圾，当我在回收它的时候。

我顺带着把内存整理一下，整理成什么样的，整理成排列的，整整齐齐的排排，坐吃果果，你们仨在这后面的，有用的，在后面跟着好，剩余所有的空间都是可以用的，very good，这叫标记整理，叫标记压缩。

这种算法也很形象，就是你的你的硬盘的碎片化整理嘛，他也没有这种内存的碎片化，它都是连续的空间，但是问题就出在效率很低啊，它是这三种之中效率最低的好，一共就这三种，从上个世纪60年代开始到今天，我告诉你。

就这三种，没有别的，不知道说清楚没有，这块有疑问吗，很简单吧，听我说，所以呢，看这里啊，就这三种算法呀，我的中文呢中文，就这三种算法都有毛病都有毛病，就是说你要是把你的内存当成一整块的时候。

无论你采用什么样的算法，都有它自己的问题，所以垃圾回收器非常聪明，它呢是用这三种算法综合运用，然后同时对内存进行了划分，产生了各种各样的不同的，形成自己个性的垃圾回收器啊，妈妈你爸爸爷爷奶奶。

叔叔阿姨都可以帮你来进行垃圾回收，但是每一种都有它自己的特点，好同学们，下面我们看垃圾回收器总的图，垃圾回收器的总图，未来放在这儿啊，好那这是垃圾回收器的总图，那么大家听我讲啊，这垃圾回收器总图呢。

在jvm从jdk一点零诞生到现在，jdk 14从一点到14，一共诞生了十种垃圾回收器，这时钟垃圾回收器，我一会儿呢沿着历史我慢慢给你捋出来，你就理解了，这时钟来机回收器它到底是怎么玩的了。

每一种的特点是什么，好我们先来把它背过，有同学说老师你这个东西要背过吗，没错你跟面试官想吹牛逼，或者你想把他吊起来打的时候，你就把它给背过，但是它也不难，这几种垃圾回收器呢，你我你先花个几十秒。

先大概看一眼，分成什么呢，分成是把内存分成两部分的，以及把内存分成多部分的，好看这里前面这六种是属于内存分带模型，后面这三种呢属于内存不分带，但是g one呢它逻辑是分带的。

econ是一个特别好玩的垃圾回收器，叫做他是他是什么都不干的垃圾回收器，好听我讲，我一个一个啊，今天是已经9。20了，没关系，我一个一个的给你们捋清楚，好吧好。


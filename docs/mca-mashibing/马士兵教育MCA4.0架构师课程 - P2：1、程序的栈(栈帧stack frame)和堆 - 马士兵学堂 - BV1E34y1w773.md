# 马士兵教育MCA4.0架构师课程 - P2：1、程序的栈(栈帧stack frame)和堆 - 马士兵学堂 - BV1E34y1w773

你可以在简历上写写啥，写这个叫熟悉GC常用算法，熟悉常见的垃圾收集器，熟悉常见的垃圾收集器，具备实际JVM调优实战的经验，就是说你听完今明两天的课，差不多有三四个小时。

就直接可以在你简历上写上这么一条来，不知道有多少同学能够意识到，当你在简历上写这么一条的时候，你这份简历可以多值多少钱呢，大三可以写吗，可以啊，没问题啊，这跟你大几没有半毛钱关系啊，可以出去吹牛逼了。

不用吹牛逼啊，这个是真正值钱的地儿，我告诉你3000块钱，至少你在简历上写这个，原来你简历值1万5，现在就值1万8，好看这里今天开始听我慢慢道来好吧，今天我主要给大家讲的到底什么是垃圾。

怎么定位这个垃圾常见的算法，常见的垃圾回收器，调优的实战，明天讲好吧，调优实战比较难，稍微复杂一些啊，说错了，其实那个实战相对容易，理论理论啊相对比较难，我们一点一点讲，放松了讲。

今天我也是第一次这么来讲，我怎么讲呢，我是从那个最底层的一个本质来跟大家聊，首先呢给大家几十秒钟，你扫一下这张图，看是不是能理解，嗯看满天只说工资才3000，没关系啊，听完就6000人要有梦想。

不然跟咸鱼有什么区别呢，好又是这张图对这张图几百年不变，只要是冯诺依曼结构的，冯诺依曼结构的计算机体系不变，这张图就永远不变，哪科都有张图，一周拿克，还有马老师的好看，这里嗯作为一台计算机来说，怎么样。

这个程序是怎么运行的呢，这里是QQ点EXE，平时呢它静静的躺在硬盘上，我想静静是吧，静静的躺在硬盘上，什么时候它执行呢，当你双击这个图标，操作系统老大会把它从硬盘load到内存好。

这个过程我们叫load，load到内存，漏到内存之后，这哥们会形成一个进程，Ok，会在内存里面形成一个进程，这个进程里面包括什么呢，包括一条一条的指令，一条一条的数据。

然后接下来CPU会一句一句的一条一条的指令，拿到自己的内部来开始执行，需要数据的时候再把数据给读过来，他真正开始执行了之后呢，实际上它还是需要内存的辅助好，这个进程的内部到底是怎么组织的呢。

好好听我讲这个进程内部怎么组织的呢，呃这块我就简单介绍到这，没问题吧，可以关注一下微信的声音哦，Sorry，你提醒了我，稍等片刻，好了，这下世界安静了，是怎么组织的呢，在这里呢我介绍程序的栈和堆的概念。

程序的栈和真，也许有同学了解过，也许有同学不了解，你认真听就可以了，呃我们来看这样一个小程序，这是我刚刚敲的，假如说啊我们自己写了一个main函数，main方法，我在里面是这么写的。

是object o等于new object，然后呢我第二句话呢，我调用了另外一个方法，这个方法叫M在内存里面到底是怎么运行的呢，听我说这就是这个进程里面的一个结构，这个进程里面结构是什么样的呢。

首先第一点，object o等于new object，这里面有两个东西，第一个是这个变量，这个小O小O在哪呢，它是位于我们的栈空间好，这里叫做站，只要是冯诺依曼结构的这样的一个程序，我告诉你啊。

它结构都一样的，这里叫做战战是什么意思呢，战战嘛，如果你稍微学过一点数据结构，就是先进后出，先进去的，后出来，后进去的，先出来，它是这样一种数据结构，你可以认为它就是一个桶。

你先把这个馒头扔到桶底下去的，你要拿的时候得先把上面拿出来，最后一个才能拿出来好，这是这个占空间，在占空间里面，首先呢会有一个战争出现，这个战争是谁呢，任何一个方法出现的时候，都会有一个战争。

任何一个方法都会有一个战争，ok main方法，main函数既然是调用main函数，那么首先在站里面会形成一个战争战争，它的英文叫STAFRAME，这叫做基于站的这样的一个一个一个结构啊。

其实除了基于站的结构之外呢，还有基于别的结构，但是基于站的结构啊，还有基于寄存器的结构，基于这样的结构是最常用，最简单的，最简洁的java就采用了这样的结构，java程序开始执行会形成会有一个站产生。

注意这个站呢一个县城一个站，每线程一个啊，你看啊，当我们呃程序开始运行的时候，这是我们的主线程了，我们主线程呢就会维护一个数据结构，这个数据结构呢就是一个站在这个站里面呢，它会生成这样的一个方法的调用。

方法的调用路径，这调用呢首先会生成我们的main方法的栈，当然main方法的站放到栈里面之后呢，叫一个战争，一个方法对应一个战争，如果说你比方说在main方法，执行到某一句话的时候。

假如说他是执行到这里了，这方法执行到这里的时候，它调用了另外一个方法，这时候会怎么办呢，会在这里暂停，然后跳到M方法里面去运行，当然这个M方法怎么运行呢，实际上就形成另外一个战争，就是这个M战争。

然后指令放在哪呢，指令永远放在最上面，那该执行哪条指令了，把这个指令呢拎出去是吧，然后他还有一个非常重要的特点，什么样的特点呢，就是如果一个方法执行结束了，比如说我M方法调用完了，M方法执行结束了。

或者main方法执行结束了，它会把它给弹出去，所弹出去是一个形象化的说法，其实呢就是把栈顶指针往下移动就可以了，栈顶指针往下移动，暂停指针往下移动，CPU要找的时候就会从下面开始找了。

就不会找上面上面就废掉了，所以这是站的一个特点，不知道我说清楚没有，这很简单啊，你稍微有一点那个计算机基础的话，一说你就应该明白，所以如果这句话。

object o new object它会首先在这个战争里，main这个战争里面生成一个小O，注意这是个小O，但是我们new出来object放哪呢，如果说这是我们new出来的object。

它是放在了我们的堆里面，这是堆空间，所以堆空间是在程序执行的时候，用来动态分配内容的空间，OK然后这哥俩之间建立一个关联，这个小O通过这个小O可以指向new出来的对象，好了。

这是大体的栈和堆的最基本的概念，那有同学可能就会说了，老师你这你讲这个是要不是讲GC的吗，怎么突然开始讲这玩意儿，因为这东西啊跟GC的发展呢叫做息息相关，好我讲到这，大家还能跟上吗，没问题的。

给老师扣个一，稍微做一下总结，就是每一个县城都会维护自己的县城站，县城站里面放着的是一个一个方法，调用调用的路径的一个战争的堆叠啊，就是一堆战争啊，M方法调了main方法调了mm呢，如果再调一个方法。

它就在上面再形成一个战争，什么时候这方法调用结束了，怎么办，啵儿往外一弹，所以有同学说了，老师那这两个有什么区别吗，好好听我讲，好好听我讲，老师这个站和对应有有什么区别吗。

这里面最重要的一个区别是什么呢，最重要的其一个区别是我不知道大家发现没有，作为占空间，当你占用了站里面空间的时候，它是自动释放的，OK我再说一遍，作为站里面的空间，它是自动释放的，这空间是自动释放。

为什么要自动释放啊，方法已结束，战争顶针啊，顶上那个格就往下移，你得找下一个继续往下运行的那个地儿去，你得跑到下一个战争空间里面了，所以上面那个战争空间就废了，直接就废了，自动释放有什么好处呢。

就是如果你有一些空间是分配在这里的话，你在这里面占的地没关系，你不需要手动释放它，你发现没有，你只需要说这方法一结束，哎哎哎它就弹出去就没有了，所以你发现没有这块空间，虽然说他也占一块空间。

但是呢你不用手工去释放它，没必要去释放它，什么时候释放main方法一结束，整个往外一弹就结束了，但是堆不一样，堆是什么，堆是在你执行过程中自己手工雕出来的，new出来了之后就会产生一个空间啊。

占了一块地方，你发现没有，那如果说你这个程序里头不停的new一个for循环，不停的往里new new new new new new new new new new new，你发现没有一个很重要的问题。

很严重的问题，这哥们儿很快这个空间就没了，是不是早晚就没了是吧，同学们，那现在的问题是你怎么去管理这块空间，占空间很简单，只要是方法一结束好，所有的占的空间就全弹出去，就没就没有了，你不用管，特别简单。

但是堆空间不行，堆空间是你要往里头分配，但是你得负责把它给回收，回收的意思是什么意思呢，回收的意思就是把这块空间标记成为可用了，原来呢是你是站着的，被别人给占住了，不能让别人用。

比其他程序不能用其他的语句，不能用，其他线程不能用，但是你必须得手工的来进行对它进行管理，什么时候呢，你觉得我用不着这个对象了，你就要把它给删掉，删掉就是做个标记，这块空间已经可以用了，已经让出来了。

不知道说清楚没有，听我说我这里讲的东西呢，跟任何的语言呢没有关系，跟语言没关系，任何语言，任何语言再强调一遍，从诞生到现在为止的，所有语言都会面临的一个问题。


# 系列 3：P24：【多线程与高并发】第二天课前复习 - 马士兵_马小雨 - BV1zh411H79h

ok不多说了，我们稍微回顾一下上节课我们讲的多线程和高并发的传闻，内容回顾一下啊，讲了县城的概念是非常简单，启动的方式嗯，有一个thread st，用rable来启动。

用executor来启动常用的一些方法，sleep with join，线程，如果需要同步加synchronized sega，不能用常量，不能用spirit类型的常量啊，不能用基础数据类型。

integer long等等，好线轴的同步，他呢锁的是对象，而不是代码，这一定要记清楚，你说的是某一个对象，是通过这个对象的对象头上面的两位来控制是不是加了锁，加了什么类型的锁。

锁呢一般来说默认的或者说this所当前对象所什么什么的class，所找个这个class类的对象，什么时候呢，如果你是普通的方法，sychronized的m普通方法锁的是this。

如果是esthetic synchronized，那么说的就是什么什么class，锁定的方法和非锁定的方法是可以同时执行的，非锁定方法人家本身就不需要去访问这个锁，所以呢你所不所动而没有任何关系。

所以你要想如果说你的某一个类想知道多线程的话，你得特别特别小心翼翼的来进行设计的，什么样的，哪些方法要加锁，哪些方法呢，不加速所升级的概念呢，就是synchronized的内部呢进行了一些相应的优化。

所升级的概念，我们稍微回顾一下这个从阿里的这种面试的变态来看的话呢，这种题后面也会慢慢的会被问到，什么叫所升级的概念呢，所升级的概念就是呃你比如说你要锁定某一个对象，那么前面有说过。

我是在这个对象头上的某两位来指定它到底锁的什么类型的锁，在对象头上还记录着当前县城，哪个县城啊，哪个县城申请了这把锁，那偏向锁的概念是什么呢，这个线程来了之后呢，先不尝试对它进行加锁。

只是记录这个线程的id值，线程id记在这，那么我们就认为呢这个对象呢是这个线程独有，下次再来申请这把锁的时候，他就会认为就是那个那个倾向于还是这个这个县城，也就是说这个锁呢。

实际上是偏向于这个第一次拿到这把锁的这个现场了，所以他没有真正的加锁，他只是说你下次来的时候判断，你如果还是原来那个现场的，你就别加锁了，继续直接访问，不要考虑这个加锁的问题了。

因此呢效率上会稍微高一些，但是如果来到县城，新的这个县城呢，不是原来那个你发现新的线程id和原来这个县城i d呢，它不等在不懂的情况下怎么办呢，进行锁升级，进行所升级。

所升级呢首先会尝试进行自旋锁的升级，什么意思呢，从偏向所升级为自旋锁，自旋锁呢就是说呃如果说这个县城在这已经拿到这把锁了，那么另外一个县城来了之后，那个人转圈循环，well，哎我能不能拿微博锁。

能不能这么说，能不能这么说啊，跟着转圈转十圈，默认是这个知识是转十圈儿，如果拿不着，这时候干嘛升级重量级锁，这哥们儿就去wait了，大家知道重量级所的概念，就是说经过我们的os，然后进入等待队列啊。

进入等待队列里头，进入等待队列之后呢，他就不再占用cpu时间了，其他占用cpu时间占用十圈，十圈完了之后呢，就进入等待队列，什么时候用自旋锁，什么时候又中了，你所呢，你你你你还还记得吗。

如果说上局他没听，你好好考虑一下这个问题，根据自旋锁和重量级锁的特点，什么时候是自选，什么时候重量级锁，自旋锁，咱们说线程数少的时候，线程数偏少的时候，使用自旋还是用重量级比较合适，如果其他条件都一样。

这肯定是自选，没错，这大家都很这很很很很很简单，旋转数少，你选2000呢，消耗的时间也不多，但是如果线程数特别多，你跟这自旋还有意义吗，2000个县城，一个县城跟那厕所上蹲着2000个线程在旁边转圈。

你盯得住吗，这肯定不行，所以一个是这给大家写一下吧，自旋叫做积极的排队啊，他是占用cpu时间的，如果你是为了队列呢，诶他就不是不占你cpu时间，在那等着消不消耗cpu的，所以如果线程数少。

这个呢p应该是偏向于自旋，如果多的话呢，应该是偏向于重量计算，只有一个，那跑就行了，那我再问你呃，大家知道你拿到这把锁之后要执行操作，如果这个操作消耗时间长，来告诉我用自旋还是用重量级锁考虑一下。


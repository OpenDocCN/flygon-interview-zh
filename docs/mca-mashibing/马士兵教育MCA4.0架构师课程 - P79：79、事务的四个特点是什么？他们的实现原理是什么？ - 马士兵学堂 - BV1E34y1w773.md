# 马士兵教育MCA4.0架构师课程 - P79：79、事务的四个特点是什么？他们的实现原理是什么？ - 马士兵学堂 - BV1E34y1w773

刚说的东西，假设两个日志啊，我明确了都要记住，我如果先写redo log，谢谢他，然后再写blog对吧，先给大家再给它这样两个方式，如果再这样写的话，这里面会有一个问题，同学们听好了，什么问题。

如果我写完redo log之后，突然写了个G，还没来得及写编lo的时候，我突然断电了，这时候会发生什么情况，写一下，刚写完redo log，没有写完blog的时候，会有什么情况发生。

你觉得会有什么情况发生，注意啊，我的read log里面写完了，写完之后，我一定会把它译写到我们磁盘里面，就算我在一起的时候突然断电了，我的read log里面只要有数据或只要有对应的记录，我在哪。

我是可以根据redo log来进行重启的，但是你要考虑一件事，你写完的redo log，你的blog里面是不记录对应信息的，那这个时候假设你有两台机器，A的操作，A机器和A服务A数据库是吧。

然后B数据库，是通过什么blog来进行数据同步的，此时你考虑清楚了，当他写完了，他没写完，你的B数据库在同步数据的时候，会不会代表这一条数据，会还是不会，对外，不会如果不会的话，就会出现一种情况。

什么情况，你的A数据库里面已经做完了这条更新操作，但是你把blog同步到B机器的时候，你的B机器里面并没有这个操作，你告诉我你ab两个机器里面数据还一致吗，一致不一致了，不一致了吧。

那不一致你的主从同步不就失败了吗，不就存在对应的一个问题了吗，是不是这意思啊，所以它是不可以的，不能先写redo log再写blog，那其实反过来道理也是一样的，如果我先写个blog。

然后后面我再写我的RELOG，这样的情况一样的吧，什么叫一样的，想好了，我先写完blog，然后没有写完redo log，这时候我们什么情况，你blog里面记录了对应数据VLOG，记录了对应的数据，好吧。

B机器我B服务器B已经将数据同步，但是REDUG都没有，此时如果出现了凡是save，或者说如果出现了断电，出现断电之后，你告诉我，你能够根据blog把数据给恢复回去吗，这个问题啊，你当你断电之后。

你能够把你根据BINLOG把数据给恢复回去吗，能不能，不能吧，里面那数据嘛肯定恢复不了，他恢复不了，意味着AGG是A的数据是有问题的，少一条，但是你的blog已经同步到B机器里面了。

B机器里面是不是会多一条记录或多一个操作，那此时你的AB两个里面的数据还一致吗，一致不一致啊，不就又不一致了吗，是不是意思，所以不管你先写redo log还是先写blog，它都是有问题的好吧。

所以这种机制有问题，因此才诞生了我刚刚给大家展示的东西，什么呢，叫两阶段提交，什么意思，我先写redo log，只不过此时我的read log，它处于的是叫prepare这个状态，然后我再写blog。

当我把blog写完之后，我事务提交了，我再把我们的redo log置为commit状态，那在整个这个执行过程中，依然在任何步骤的时候，都有可能会出现断电情况，比如说这如果断电了，可以了，听好了。

这如果断电了，当这断电之后，我需要做什么判断它的运行机制是这样的，听好了，如果在此处出现断电了，那我在恢复的时候，我会先检测我的redo log，我只是do log里面状态。

我检测log之后发现当前的RELOG属于PREPA状态，当它处于prep状态之后，我再去blog里面找对应的数据，比如blog里面是否同步记录了与之相同的操作，如果有，如果有。

那么此时把刚刚redo里面的prepare状态，改成commit状态，如果没有的话，干什么事，把刚刚redo log里面的PDD这条日志，直接置为失效，我直接认为无效数据，这样的话。

我的redo log和我们的blog，能不能保持保持数据一致，可以吧，是刚刚这个锻炼的过程那一样的，在下面这个步骤里面，它也可能断电，当它翻面之后一样逻辑啊，我先找log，我一找诶。

发现一个log里面有prepare状态的数据，这时候我在找blog里面找我一找blog，blog里面是不是有对应的记录，有对应记录怎么办，把刚刚的prepare状态的数据改成commit状态。

这样的话两条数据记录都保持了完全一致，所以不管你依靠哪个数据来进行，数据恢复的时候，它都不会出现数据的不一致性的问题，这东西就称之为叫两阶段提交来，这东西TM同学给老师扣一，能听懂吗。

所以啊这东西在面试中也会经常被问到，你要给面试官把这东西给讲清楚，它对应它对应的东西，老师redo和blog fpl的方式能替换吗，不可以，因为blog它没有prepare这样一个状态。

blog没有prepare这样一个状态，没有prepare一个状态好吧，所以他不可以互换位置好了，这是个两阶段提交，这东西我知道这么多，所以当提到log的时候，你要把blog整合起来。

了解一下它的两阶段提交就可以了，VLOG在server端链中还有吗，它是持久化到磁盘的，怎么会没有呢，它是持久化到磁盘的，所以一定是有的，注意断电之后数据丢失的话，只会把内存里面的数据给丢失掉。

你磁盘里面的数据是不会发生丢失的，所以不用担心这件事，好吧好了，刚刚我解释了原子性，通过undo log来实现隔离性，通过MVCC加锁来实现持久性，通过redo log来实现，但是我唯独没有提一个东西。

就是我们的一致性，这一年我要强调一件事，同学们听好了，这里面我会写一句话，记住了，为什么一致性没有写具体的实现方式，因为有很重要的一句话，一致性是我们根本的追求，一致性是实现。

方式是由其他三个特点来保证的，明白意思吧，也就是说它没有什么具体的实现点，其他三个特征共同保证了我们的一致性，问题来这儿能听懂，同学扣一能听懂吗，赶快记一点好不好，好了当这些问题都聊完了之后。

下面我们进入到一个环节，什么环节，我们就要讲一下我们的MVCC这玩意儿，把重点了一下，MCC这玩意，MVCC坦白说还是有那么一丢丢复杂的，很多同学在了解MCC的时候。

其实怎么说理解的都有多少有点有失偏颇，那今天我们重点把MVCC对应的实现机制，给大家讲清楚啊，MVC这玩意儿VC刚刚读完的，我都说过了啊，先聊聊mv cc刚刚解释过了啊，什么叫MVCC啊。

它的翻译是什么县城所吗，不是跟县城所没有半毛关系，它叫做什么叫多版本并发啊，这它对应的一个全称啊，既然涉及到并发了，那这里面会有一个问题，同学们数据库里面的并发大概分几种情况挺好。

数据库里面的并发大概分几种情况，这是什么，有多个事物在进行同时操作的时候，有几种情况，三种哪三种啊，第一种叫读读好吧，第二种叫读写啊，第三种叫写写，这都是我们产生这种并发读取的时候，要产生的一些操作。

比如说同时读都是读还是写还是有毒有写啊，这样的一个这样三种情况，那这样的情况我们要解决问题什么问题，这三种情况在进行并发操作的时候，它会有对应的问题呢，比如第一个读读会有数据安全问题吗。

他需要进行立法控制吗，需不需要，不需要不存在任何问题，也不需要并发控制，因为你在进行数据读取的时候，它并没有实际的改变我们的数据值吧，所以他不需要了好吧，那第二个读写会有问题吗，有吧有数据安全问题。

比如说我们之前提到的什么脏读对吧，幻读不可重复读啊，都是这种各种机制里面它要存在的一个问题啊，这东西，然后第三个写写写写会有问题吗，有没有有有数据安全问题，是可能存在丢失而叫更新丢失问题。

就说是存在这些对应的一些情况的，当存在这些对应情况之后，我们总要考虑解决方案，对不对，在考虑解决方案的时候，你就什么解决方案，最普通的方式我可以通过锁的机制来实现吗，比如说加锁锁是可以解决这个问题的。

但是我在使用锁的时候，明显有一个问题是什么，效率低吧，是不是效率低啊，那如果我想保证我的效率足够高，我应该怎么办，怎么做幻读的问题，一会儿来解释，别着急好吧，锁它的效率一定是很低的。

但是这个时候你可以联想一下，你之前在java那种并发编程的时候，java里面在进行并发编程的时候，你除了可以加这种single max这样的一些锁之外，还可以干什么事，好了话费剃头说了一个东西叫CAS。

CAS叫什么叫compare and sweep，其实我们的mv cc类似于这样的机制，也就是说他不需要去进行加锁，当然在MACC里面，它并不是进行对比的，只不过它减少了我们所对应的一些存在的问题。

就是说它是用来解决枷锁这样的一个问题的，明白意思吧，跟cs不一样，但类似的机制是一样的，类似的机制是一样的，那到底它怎么实现呢，实现的方式非常简单，刚刚有些同学提到了隔离级别，隔离级别的东西。

我希望同学们能够一会儿再聊，我们一会再聊隔离级别相关的问题，先扔一边，等需要聊的时候再来个离别，不需要聊，先不聊它好，在讲MVCC对应的实现原理之前，我需要同学们先具备两个最基础的概念。

第一个概念叫什么叫当前读，第二个概念叫快照读，就是说你必须要把这两个名词搞清楚，什么叫当前读，是啥意思，啊什么当前局记住了所谓的当前读，表达的意思是说在进行数据读取的时候，读取的都是最新的版本数据。

记住啊，叫最新的版本数据啊，而且在读取的时候，还要保证其他并发事务不能够修改，我们当前的这些记录，会对我们读取的记录进行加锁操作，这叫当前组，除了当前读之外，还有第二个概念，叫什么叫快照读。

那什么叫快照读啊，一个是读最新的数据，那快照读读啥读什么，对读取的是历史版本的数据，好吧，是有可能读取到对应的历史版本数据的哇，那这里面会有一个问题，老师什么样的操作会触发当前读。

什么样的操作会触发快照读呢，注意了，这样说明一下，我们当前读触发操作有以下几个，写下第一个，比如说select lock in share model，什么意思，加读锁吧。

比如说select for update加解锁吧，比如说我们执行的update操作对吧，delete操作对吧，包括A4的操作，像这些操作在进行操作的时候，都都都基本上都是当前读完全读，它并没有快照读。

那什么时候会触发我们的快照读呢，也非常简单，它有且仅有一个，什么东西呢，叫select，注意，最普通的select有可能触发的是我们的快到数据，而不是我们最新的数据，有人有这样的感受吗。

就你读到的数据是旧的数据，有这样的感受吗，你之前在操作数据库的时候，有读到过旧的数据吗，有没有，想想回忆一下有没有，如果你说没有，那么我就要给大家举例子了啊，如果你说没有，就要举例子了。

举例子来看一下它到底是什么样的一个情况。

![](img/3b251ce82e74b3d731b70bcffe5120cd_1.png)

已经更新了，但还是旧的，是这样的情况，来看好这个例子啊。

![](img/3b251ce82e74b3d731b70bcffe5120cd_3.png)

下面我来举例子说明了还是一样，我们不可能光讲理论知识。

![](img/3b251ce82e74b3d731b70bcffe5120cd_5.png)

还是要带点实操的好吧，let's go root杠P。

![](img/3b251ce82e74b3d731b70bcffe5120cd_7.png)

我来演示一个场景，你来告诉我对应的关掉吧，我来演示一个场景。

![](img/3b251ce82e74b3d731b70bcffe5120cd_9.png)

你来告诉我，对应的答案和对应的效果分别是什么，因为很重要，好吧。

![](img/3b251ce82e74b3d731b70bcffe5120cd_11.png)

来了两个窗口同时进来。

![](img/3b251ce82e74b3d731b70bcffe5120cd_13.png)

mysql u root杠P123456，进来进来之后，我们use demo这个数据库，然后呢在里面我去创建一张表，grade table ut18连开八九个字的id，Int primary ke。

内部watch。

![](img/3b251ce82e74b3d731b70bcffe5120cd_15.png)

这个SQL语句足够简单了，我觉得这个SQL语句有人看不懂吗，没有吧，足够简单了啊，然后insert into t18value，写这个值一逗号一，好了，往里面插入了三条结果。

select将from p18问题吧，这边也是一样的，Select。

![](img/3b251ce82e74b3d731b70bcffe5120cd_17.png)

行from t18。

![](img/3b251ce82e74b3d731b70bcffe5120cd_19.png)

两边数据一样不一样，告诉我两边数据是否一致，一样吧，没有任何的区别好吧，下面我要做一些最基本的操作了，第一个操作是干嘛，我们为了模拟事物的一个执行过程，或者执行情况，我需要把自动提交事务的按钮给关闭掉。

所以叫set auto commit等于零走。

![](img/3b251ce82e74b3d731b70bcffe5120cd_21.png)

![](img/3b251ce82e74b3d731b70bcffe5120cd_22.png)

然后commit一下，我现在把事务自动提交给关闭掉了，当我关闭掉之后，我为了模拟两个事物啊，AB是两两个，这是两个窗口，一个A1个B，那么我能不能手动的去开启我们的事物，我能手动开启事务吗，可以吧。

两种方式，第一种是第二个begin。

![](img/3b251ce82e74b3d731b70bcffe5120cd_24.png)

我依然执行begin操作，当我开启事务之后，我的问题来了，同学们，现在我开启了一个新的事物，两边数据是否一致，你这个意思一是吧，这个没啥问题啊，肯定是一致的，如果一致的话，我们就要考虑一件事。

我在第二个窗口里面，我做一个update操作，比如说update t18，set name等于连。

![](img/3b251ce82e74b3d731b70bcffe5120cd_26.png)

然后结束，我现在更新完成之后，两边的数据是否一致，现在一样吗，有人会说老师应该不一样吧，为什么，因为你从右边窗口里面是我没提交，我现在把它给提交掉，我的问题听好了，问题来了，当我这边提交完成之后。

我在这边进行数据的查询，我查询到的是零还是123，告诉我零还是123，来各抒己见好吧，发表你们的看法，好了，有说连的，有说123的，但是我看到的情况是123的，情况应该是偏多的。

但是实际查询起来你的结果它是连，并不是123，还有刘大说，老师要看隔离级别，这块跟隔离级跟隔离级别没有半毛钱关系，没有半毛钱关系，我先问一下我们当前的隔离级别，MYSQL默认的隔离级别是什么。

什么查一下嘛，At at at trition，什么repeatable read，因为我从来没有改变过隔离级别，所以别的级别是一模一样的。



![](img/3b251ce82e74b3d731b70bcffe5120cd_28.png)

没有任何的区别，这样你首先要记住了好吧，先把这东西记住来。

![](img/3b251ce82e74b3d731b70bcffe5120cd_30.png)

现在我把两边的事物全部提交掉，commit我在演示另外一种情况，看好了另外一种情况，什么情况，我现在都commit掉了，我同时再开启我们的输入，开始之后，我看一下我们的数据，三星from p18。



![](img/3b251ce82e74b3d731b70bcffe5120cd_32.png)

现在是一样吗，现在数据一样吗，一样吗，一模一样，隔离系列我也没动过，我依然在第二个窗口里面，我做一个更新操作，Update p18，set name等于回合单走，我一样在提交。

我现在读取到的结果是123还是连，什么，连是吧，是连吧是连哎，为什么，为什么在刚刚这里面的时候，我就可以读到最新的数据，为什么在这的时候我就读不到最新的数据了。



![](img/3b251ce82e74b3d731b70bcffe5120cd_34.png)

挺好啊，在我第一次演示的时候，它是可以读到最新的数据的，修改之后的数据，但在第二次的时候。

![](img/3b251ce82e74b3d731b70bcffe5120cd_36.png)

我就读取不到修改之后的数据了，你在这边进行查询的话，他已经改了，他的面，数据明显已经不一致了，小孩那桌数据库bug，怎么可能数据库bug。



![](img/3b251ce82e74b3d731b70bcffe5120cd_38.png)

这里面其实涉及到的就是当前读和快，照读的问题，跟缓存没有半毛钱关系，这也是MVCC它存在的一个重要的原理，重要的点好吧，对，区分点是什么，是我在读取之前，我进行了一次查询操作。

为什么我执行一次查询操作之后，就能够达到当前的事物，但是达到效果了，原因是什么，这个原因在于MVCC。



![](img/3b251ce82e74b3d731b70bcffe5120cd_40.png)

所以下面我要详细的去讲一下，MVCC具体的实现机制了。

![](img/3b251ce82e74b3d731b70bcffe5120cd_42.png)

你准备好了吗，想搞明白刚刚为什么会出现这种情况吗。

![](img/3b251ce82e74b3d731b70bcffe5120cd_44.png)

为什么我多执行了一次查询操作之后，两次结果就不一样了，来想知道的扣一体验一下自己好吧。

![](img/3b251ce82e74b3d731b70bcffe5120cd_46.png)

![](img/3b251ce82e74b3d731b70bcffe5120cd_47.png)

这时候核心点和重点来了，来先说MCCMACC在进行底层实现的时候，它总共包含了三部分操作，第一部分叫什么叫隐藏字段，什么叫隐藏字段，也就是说在我们的MVCC进行实际操作的时候。

它其实除了我们看到的字段之外，会包含一些包含一些我们看不到的字段，cover字段有几个呢，有很多这块我重点说三个，第一个叫什么叫dB下划线，TRX下划线ab，这是第一个隐藏字段。

它要表述的或它表示什么意思呢，其实非常简单啊，表示什么叫记创建这条记录啊，或者最后一次修改该记录的事务id，这是第一个字段要表示的意思，还有第二个隐藏字段叫什么叫DB下划线，肉下划线PT2。

它表示什么意思，它叫做，哪来叫做回滚指针好吧，指向数据的上一个版本，上一版本不一样的，还包含第三个字段，叫dB下划线，我昨天说过的东西叫ROID吗，什么意思啊。



![](img/3b251ce82e74b3d731b70bcffe5120cd_49.png)